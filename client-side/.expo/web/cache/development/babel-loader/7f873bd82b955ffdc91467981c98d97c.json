{"ast":null,"code":"import { cond, sub, divide, multiply, add, block, set, greaterOrEq, proc } from \"../base\";\nvar internalTiming = proc(function (clock, time, frameTime, position, finished, toValue, duration, nextProgress, progress, newFrameTime) {\n  var state = {\n    time,\n    finished,\n    frameTime,\n    position\n  };\n  var config = {\n    duration,\n    toValue\n  };\n  var distanceLeft = sub(config.toValue, state.position);\n  var fullDistance = divide(distanceLeft, sub(1, progress));\n  var startPosition = sub(config.toValue, fullDistance);\n  var nextPosition = add(startPosition, multiply(fullDistance, nextProgress));\n  return block([cond(greaterOrEq(newFrameTime, config.duration), [set(state.position, config.toValue), set(state.finished, 1)], set(state.position, nextPosition)), set(state.frameTime, newFrameTime), set(state.time, clock)]);\n});\nexport default function (clock, state, config) {\n  if (config.duration === 0) {\n    return block([set(state.position, config.toValue), set(state.finished, 1)]);\n  }\n\n  var lastTime = cond(state.time, state.time, clock);\n  var newFrameTime = add(state.frameTime, sub(clock, lastTime));\n  var nextProgress = config.easing(divide(newFrameTime, config.duration));\n  var progress = config.easing(divide(state.frameTime, config.duration));\n  return internalTiming(clock, state.time, state.frameTime, state.position, state.finished, config.toValue, config.duration, nextProgress, progress, newFrameTime);\n}","map":{"version":3,"sources":["timing.js"],"names":["internalTiming","proc","state","position","config","toValue","distanceLeft","sub","fullDistance","divide","startPosition","nextPosition","add","multiply","block","cond","greaterOrEq","set","lastTime","newFrameTime","nextProgress","progress"],"mappings":"AAAA,SAAA,IAAA,EAAA,GAAA,EAAA,MAAA,EAAA,QAAA,EAAA,GAAA,EAAA,KAAA,EAAA,GAAA,EAAA,WAAA,EAAA,IAAA;AAYA,IAAMA,cAAc,GAAGC,IAAI,CAAC,UAAA,KAAA,EAAA,IAAA,EAAA,SAAA,EAAA,QAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,YAAA,EAAA,QAAA,EAAA,YAAA,EAW1B;AACA,MAAMC,KAAK,GAAG;AAAA,IAAA,IAAA;AAAA,IAAA,QAAA;AAAA,IAAA,SAAA;AAIZC,IAAAA;AAJY,GAAd;AAOA,MAAMC,MAAM,GAAG;AAAA,IAAA,QAAA;AAEbC,IAAAA;AAFa,GAAf;AAKA,MAAMC,YAAY,GAAGC,GAAG,CAACH,MAAM,CAAP,OAAA,EAAiBF,KAAK,CAA9C,QAAwB,CAAxB;AACA,MAAMM,YAAY,GAAGC,MAAM,CAAA,YAAA,EAAeF,GAAG,CAAA,CAAA,EAA7C,QAA6C,CAAlB,CAA3B;AACA,MAAMG,aAAa,GAAGH,GAAG,CAACH,MAAM,CAAP,OAAA,EAAzB,YAAyB,CAAzB;AACA,MAAMO,YAAY,GAAGC,GAAG,CAAA,aAAA,EAAgBC,QAAQ,CAAA,YAAA,EAAhD,YAAgD,CAAxB,CAAxB;AAEA,SAAOC,KAAK,CAAC,CACXC,IAAI,CACFC,WAAW,CAAA,YAAA,EAAeZ,MAAM,CAD9B,QACS,CADT,EAEF,CAACa,GAAG,CAACf,KAAK,CAAN,QAAA,EAAiBE,MAAM,CAA3B,OAAI,CAAJ,EAAsCa,GAAG,CAACf,KAAK,CAAN,QAAA,EAFvC,CAEuC,CAAzC,CAFE,EAGFe,GAAG,CAACf,KAAK,CAAN,QAAA,EAJM,YAIN,CAHD,CADO,EAMXe,GAAG,CAACf,KAAK,CAAN,SAAA,EANQ,YAMR,CANQ,EAOXe,GAAG,CAACf,KAAK,CAAN,IAAA,EAPL,KAOK,CAPQ,CAAD,CAAZ;AA7BF,CAA2B,CAA3B;AAwCA,eAAe,UAAA,KAAA,EAAA,KAAA,EAAA,MAAA,EAA+B;AAC5C,MAAIE,MAAM,CAANA,QAAAA,KAAJ,CAAA,EAA2B;AAEzB,WAAOU,KAAK,CAAC,CAACG,GAAG,CAACf,KAAK,CAAN,QAAA,EAAiBE,MAAM,CAA3B,OAAI,CAAJ,EAAsCa,GAAG,CAACf,KAAK,CAAN,QAAA,EAAtD,CAAsD,CAAzC,CAAD,CAAZ;AACD;;AACD,MAAMgB,QAAQ,GAAGH,IAAI,CAACb,KAAK,CAAN,IAAA,EAAaA,KAAK,CAAlB,IAAA,EAArB,KAAqB,CAArB;AACA,MAAMiB,YAAY,GAAGP,GAAG,CAACV,KAAK,CAAN,SAAA,EAAkBK,GAAG,CAAA,KAAA,EAA7C,QAA6C,CAArB,CAAxB;AACA,MAAMa,YAAY,GAAGhB,MAAM,CAANA,MAAAA,CAAcK,MAAM,CAAA,YAAA,EAAeL,MAAM,CAA9D,QAAyC,CAApBA,CAArB;AACA,MAAMiB,QAAQ,GAAGjB,MAAM,CAANA,MAAAA,CAAcK,MAAM,CAACP,KAAK,CAAN,SAAA,EAAkBE,MAAM,CAA7D,QAAqC,CAApBA,CAAjB;AACA,SAAOJ,cAAc,CAAA,KAAA,EAEnBE,KAAK,CAFc,IAAA,EAGnBA,KAAK,CAHc,SAAA,EAInBA,KAAK,CAJc,QAAA,EAKnBA,KAAK,CALc,QAAA,EAMnBE,MAAM,CANa,OAAA,EAOnBA,MAAM,CAPa,QAAA,EAAA,YAAA,EAAA,QAAA,EAArB,YAAqB,CAArB;AAYD","sourcesContent":["import {\n  cond,\n  sub,\n  divide,\n  multiply,\n  add,\n  block,\n  set,\n  greaterOrEq,\n  proc,\n} from '../base';\n\nconst internalTiming = proc(function(\n  clock,\n  time,\n  frameTime,\n  position,\n  finished,\n  toValue,\n  duration,\n  nextProgress,\n  progress,\n  newFrameTime\n) {\n  const state = {\n    time,\n    finished,\n    frameTime,\n    position,\n  };\n\n  const config = {\n    duration,\n    toValue,\n  };\n\n  const distanceLeft = sub(config.toValue, state.position);\n  const fullDistance = divide(distanceLeft, sub(1, progress));\n  const startPosition = sub(config.toValue, fullDistance);\n  const nextPosition = add(startPosition, multiply(fullDistance, nextProgress));\n\n  return block([\n    cond(\n      greaterOrEq(newFrameTime, config.duration),\n      [set(state.position, config.toValue), set(state.finished, 1)],\n      set(state.position, nextPosition)\n    ),\n    set(state.frameTime, newFrameTime),\n    set(state.time, clock),\n  ]);\n});\n\nexport default function(clock, state, config) {\n  if (config.duration === 0) {\n    // when duration is zero we end the timing immediately\n    return block([set(state.position, config.toValue), set(state.finished, 1)]);\n  }\n  const lastTime = cond(state.time, state.time, clock);\n  const newFrameTime = add(state.frameTime, sub(clock, lastTime));\n  const nextProgress = config.easing(divide(newFrameTime, config.duration));\n  const progress = config.easing(divide(state.frameTime, config.duration));\n  return internalTiming(\n    clock,\n    state.time,\n    state.frameTime,\n    state.position,\n    state.finished,\n    config.toValue,\n    config.duration,\n    nextProgress,\n    progress,\n    newFrameTime\n  );\n}\n"]},"metadata":{},"sourceType":"module"}