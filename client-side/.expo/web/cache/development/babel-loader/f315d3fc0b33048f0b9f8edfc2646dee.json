{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Keyboard from \"react-native-web/dist/exports/Keyboard\";\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport Animated from 'react-native-reanimated';\nvar {\n  event,\n  divide,\n  onChange,\n  cond,\n  eq,\n  round,\n  call,\n  Value\n} = Animated;\nexport default class ScrollPager extends React.Component {\n  constructor() {\n    var _this;\n\n    super(...arguments);\n    _this = this;\n\n    _defineProperty(this, \"initialOffset\", {\n      x: this.props.navigationState.index * this.props.layout.width,\n      y: 0\n    });\n\n    _defineProperty(this, \"wasTouched\", false);\n\n    _defineProperty(this, \"interactionHandle\", null);\n\n    _defineProperty(this, \"scrollViewRef\", React.createRef());\n\n    _defineProperty(this, \"jumpTo\", key => {\n      this.wasTouched = false;\n      var {\n        navigationState,\n        keyboardDismissMode,\n        onIndexChange\n      } = this.props;\n      var index = navigationState.routes.findIndex(route => route.key === key);\n\n      if (navigationState.index === index) {\n        this.scrollTo(index * this.props.layout.width);\n      } else {\n        onIndexChange(index);\n\n        if (keyboardDismissMode === 'auto') {\n          Keyboard.dismiss();\n        }\n      }\n    });\n\n    _defineProperty(this, \"scrollTo\", function (x) {\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (_this.scrollViewRef.current) {\n        var _this$scrollViewRef$c, _this$scrollViewRef$c2;\n\n        var scrollView = typeof ((_this$scrollViewRef$c = _this.scrollViewRef.current) === null || _this$scrollViewRef$c === void 0 ? void 0 : _this$scrollViewRef$c.scrollTo) === 'function' ? _this.scrollViewRef.current : (_this$scrollViewRef$c2 = _this.scrollViewRef.current) === null || _this$scrollViewRef$c2 === void 0 ? void 0 : _this$scrollViewRef$c2.getNode();\n        scrollView === null || scrollView === void 0 ? void 0 : scrollView.scrollTo({\n          x,\n          animated: animated\n        });\n      }\n    });\n\n    _defineProperty(this, \"enterListeners\", []);\n\n    _defineProperty(this, \"addListener\", (type, listener) => {\n      switch (type) {\n        case 'enter':\n          this.enterListeners.push(listener);\n          break;\n      }\n    });\n\n    _defineProperty(this, \"removeListener\", (type, listener) => {\n      switch (type) {\n        case 'enter':\n          {\n            var index = this.enterListeners.indexOf(listener);\n\n            if (index > -1) {\n              this.enterListeners.splice(index, 1);\n            }\n\n            break;\n          }\n      }\n    });\n\n    _defineProperty(this, \"position\", new Animated.Value(this.props.navigationState.index * this.props.layout.width));\n\n    _defineProperty(this, \"onScroll\", event([{\n      nativeEvent: {\n        contentOffset: {\n          x: this.position\n        }\n      }\n    }]));\n\n    _defineProperty(this, \"layoutWidthNode\", new Value(this.props.layout.width));\n\n    _defineProperty(this, \"relativePosition\", divide(this.position, this.layoutWidthNode));\n  }\n\n  componentDidMount() {\n    if (this.props.layout.width) {\n      this.scrollTo(this.props.navigationState.index * this.props.layout.width, false);\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    var offset = this.props.navigationState.index * this.props.layout.width;\n\n    if (prevProps.navigationState.routes.length !== this.props.navigationState.routes.length || prevProps.layout.width !== this.props.layout.width) {\n      this.scrollTo(offset, false);\n    } else if (prevProps.navigationState.index !== this.props.navigationState.index) {\n      this.scrollTo(offset);\n    }\n\n    if (prevProps.layout.width !== this.props.layout.width) {\n      this.layoutWidthNode.setValue(this.props.layout.width);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.interactionHandle !== null) {\n      InteractionManager.clearInteractionHandle(this.interactionHandle);\n    }\n  }\n\n  render() {\n    var {\n      children,\n      layout,\n      onSwipeStart,\n      onSwipeEnd,\n      overscroll,\n      onIndexChange,\n      navigationState\n    } = this.props;\n\n    var handleSwipeStart = () => {\n      this.wasTouched = false;\n      onSwipeStart === null || onSwipeStart === void 0 ? void 0 : onSwipeStart();\n      this.interactionHandle = InteractionManager.createInteractionHandle();\n    };\n\n    var handleSwipeEnd = () => {\n      this.wasTouched = true;\n      onSwipeEnd === null || onSwipeEnd === void 0 ? void 0 : onSwipeEnd();\n\n      if (this.interactionHandle !== null) {\n        InteractionManager.clearInteractionHandle(this.interactionHandle);\n      }\n    };\n\n    return children({\n      position: this.relativePosition,\n      addListener: this.addListener,\n      removeListener: this.removeListener,\n      jumpTo: this.jumpTo,\n      render: children => React.createElement(Animated.ScrollView, {\n        pagingEnabled: true,\n        directionalLockEnabled: true,\n        keyboardDismissMode: \"on-drag\",\n        keyboardShouldPersistTaps: \"always\",\n        overScrollMode: \"never\",\n        scrollToOverflowEnabled: true,\n        scrollEnabled: this.props.swipeEnabled,\n        automaticallyAdjustContentInsets: false,\n        bounces: overscroll,\n        scrollsToTop: false,\n        showsHorizontalScrollIndicator: false,\n        scrollEventThrottle: 1,\n        onScroll: this.onScroll,\n        onScrollBeginDrag: handleSwipeStart,\n        onScrollEndDrag: handleSwipeEnd,\n        onMomentumScrollEnd: this.onScroll,\n        contentOffset: this.initialOffset,\n        style: styles.container,\n        contentContainerStyle: layout.width ? {\n          flexDirection: 'row',\n          width: layout.width * navigationState.routes.length,\n          flex: 1\n        } : null,\n        ref: this.scrollViewRef\n      }, children, React.createElement(Animated.Code, {\n        exec: onChange(this.relativePosition, cond(eq(round(this.relativePosition), this.relativePosition), [call([this.relativePosition], (_ref) => {\n          var [relativePosition] = _ref;\n\n          if (this.wasTouched) {\n            onIndexChange(relativePosition);\n            this.wasTouched = false;\n          }\n        })]))\n      }))\n    });\n  }\n\n}\n\n_defineProperty(ScrollPager, \"defaultProps\", {\n  bounces: true\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1\n  }\n});","map":{"version":3,"sources":["ScrollPager.tsx"],"names":["Value","ScrollPager","React","bounces","componentDidMount","componentDidUpdate","offset","prevProps","componentWillUnmount","InteractionManager","x","y","key","onIndexChange","index","navigationState","route","keyboardDismissMode","Keyboard","animated","scrollView","Animated","event","nativeEvent","contentOffset","position","divide","render","handleSwipeStart","onSwipeStart","handleSwipeEnd","onSwipeEnd","children","addListener","removeListener","jumpTo","styles","flexDirection","width","layout","flex","scrollViewRef","onChange","cond","eq","round","call","container"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { StyleSheet, Keyboard, InteractionManager } from 'react-native';\nimport Animated from 'react-native-reanimated';\nimport { Props } from './Pager';\nimport { Route, Listener } from './types';\n\nconst { event, divide, onChange, cond, eq, round, call, Value } = Animated;\n\ntype State = {\n  initialOffset: { x: number; y: number };\n};\n\nexport default class ScrollPager<T extends Route> extends React.Component<\n  Props<T> & { overscroll?: boolean },\n  State\n> {\n  static defaultProps = {\n    bounces: true,\n  };\n\n  componentDidMount() {\n    if (this.props.layout.width) {\n      this.scrollTo(\n        this.props.navigationState.index * this.props.layout.width,\n        false\n      );\n    }\n  }\n\n  componentDidUpdate(prevProps: Props<T>) {\n    const offset = this.props.navigationState.index * this.props.layout.width;\n\n    if (\n      prevProps.navigationState.routes.length !==\n        this.props.navigationState.routes.length ||\n      prevProps.layout.width !== this.props.layout.width\n    ) {\n      this.scrollTo(offset, false);\n    } else if (\n      prevProps.navigationState.index !== this.props.navigationState.index\n    ) {\n      this.scrollTo(offset);\n    }\n\n    if (prevProps.layout.width !== this.props.layout.width) {\n      this.layoutWidthNode.setValue(this.props.layout.width);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.interactionHandle !== null) {\n      InteractionManager.clearInteractionHandle(this.interactionHandle);\n    }\n  }\n\n  private initialOffset = {\n    x: this.props.navigationState.index * this.props.layout.width,\n    y: 0,\n  };\n\n  private wasTouched: boolean = false;\n\n  // InteractionHandle to handle tasks around animations\n  private interactionHandle: number | null = null;\n\n  private scrollViewRef = React.createRef<Animated.ScrollView>();\n\n  private jumpTo = (key: string) => {\n    this.wasTouched = false;\n    const { navigationState, keyboardDismissMode, onIndexChange } = this.props;\n\n    const index = navigationState.routes.findIndex(\n      (route) => route.key === key\n    );\n\n    if (navigationState.index === index) {\n      this.scrollTo(index * this.props.layout.width);\n    } else {\n      onIndexChange(index);\n      if (keyboardDismissMode === 'auto') {\n        Keyboard.dismiss();\n      }\n    }\n  };\n\n  private scrollTo = (x: number, animated = true) => {\n    if (this.scrollViewRef.current) {\n      // getNode() is not necessary in newer versions of React Native\n      const scrollView =\n        // @ts-ignore\n        typeof this.scrollViewRef.current?.scrollTo === 'function'\n          ? this.scrollViewRef.current\n          : this.scrollViewRef.current?.getNode();\n\n      // @ts-ignore\n      scrollView?.scrollTo({\n        x,\n        animated: animated,\n      });\n    }\n  };\n\n  private enterListeners: Listener[] = [];\n\n  private addListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter':\n        this.enterListeners.push(listener);\n        break;\n    }\n  };\n\n  private removeListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter': {\n        const index = this.enterListeners.indexOf(listener);\n\n        if (index > -1) {\n          this.enterListeners.splice(index, 1);\n        }\n\n        break;\n      }\n    }\n  };\n\n  private position = new Animated.Value(\n    this.props.navigationState.index * this.props.layout.width\n  );\n\n  private onScroll = event([\n    {\n      nativeEvent: {\n        contentOffset: {\n          x: this.position,\n        },\n      },\n    },\n  ]);\n\n  private layoutWidthNode = new Value(this.props.layout.width);\n\n  private relativePosition = divide(this.position, this.layoutWidthNode);\n\n  render() {\n    const {\n      children,\n      layout,\n      onSwipeStart,\n      onSwipeEnd,\n      overscroll,\n      onIndexChange,\n      navigationState,\n    } = this.props;\n\n    const handleSwipeStart = () => {\n      this.wasTouched = false;\n      onSwipeStart?.();\n      this.interactionHandle = InteractionManager.createInteractionHandle();\n    };\n\n    const handleSwipeEnd = () => {\n      this.wasTouched = true;\n      onSwipeEnd?.();\n      if (this.interactionHandle !== null) {\n        InteractionManager.clearInteractionHandle(this.interactionHandle);\n      }\n    };\n\n    return children({\n      position: this.relativePosition,\n      addListener: this.addListener,\n      removeListener: this.removeListener,\n      jumpTo: this.jumpTo,\n      render: (children) => (\n        <Animated.ScrollView\n          pagingEnabled\n          directionalLockEnabled\n          keyboardDismissMode=\"on-drag\"\n          keyboardShouldPersistTaps=\"always\"\n          overScrollMode=\"never\"\n          scrollToOverflowEnabled\n          scrollEnabled={this.props.swipeEnabled}\n          automaticallyAdjustContentInsets={false}\n          bounces={overscroll}\n          scrollsToTop={false}\n          showsHorizontalScrollIndicator={false}\n          scrollEventThrottle={1}\n          onScroll={this.onScroll}\n          onScrollBeginDrag={handleSwipeStart}\n          onScrollEndDrag={handleSwipeEnd}\n          onMomentumScrollEnd={this.onScroll}\n          contentOffset={this.initialOffset}\n          style={styles.container}\n          contentContainerStyle={\n            layout.width\n              ? {\n                  flexDirection: 'row',\n                  width: layout.width * navigationState.routes.length,\n                  flex: 1,\n                }\n              : null\n          }\n          ref={this.scrollViewRef}\n        >\n          {children}\n          <Animated.Code\n            exec={onChange(\n              this.relativePosition,\n              cond(eq(round(this.relativePosition), this.relativePosition), [\n                call([this.relativePosition], ([relativePosition]) => {\n                  if (this.wasTouched) {\n                    onIndexChange(relativePosition);\n                    this.wasTouched = false;\n                  }\n                }),\n              ])\n            )}\n          />\n        </Animated.ScrollView>\n      ),\n    });\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n});\n"]},"metadata":{},"sourceType":"module"}