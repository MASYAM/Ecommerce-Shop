{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport findNodeHandleRN from \"react-native-web/dist/exports/findNodeHandle\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport Touchable from \"react-native-web/dist/exports/Touchable\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport deepEqual from 'fbjs/lib/areEqual';\nimport RNGestureHandlerModule from \"./RNGestureHandlerModule\";\nimport State from \"./State\";\n\nfunction findNodeHandle(node) {\n  if (Platform.OS === 'web') return node;\n  return findNodeHandleRN(node);\n}\n\nvar {\n  UIManager = {}\n} = NativeModules;\nvar customGHEventsConfig = {\n  onGestureHandlerEvent: {\n    registrationName: 'onGestureHandlerEvent'\n  },\n  onGestureHandlerStateChange: {\n    registrationName: 'onGestureHandlerStateChange'\n  }\n};\nUIManager.genericDirectEventTypes = _objectSpread(_objectSpread({}, UIManager.genericDirectEventTypes), customGHEventsConfig);\n\nif (UIManager.getConstants) {\n  UIManager.getConstants().genericDirectEventTypes = _objectSpread(_objectSpread({}, UIManager.getConstants().genericDirectEventTypes), customGHEventsConfig);\n}\n\nvar {\n  setJSResponder: oldSetJSResponder = () => {},\n  clearJSResponder: oldClearJSResponder = () => {}\n} = UIManager;\n\nUIManager.setJSResponder = (tag, blockNativeResponder) => {\n  RNGestureHandlerModule.handleSetJSResponder(tag, blockNativeResponder);\n  oldSetJSResponder(tag, blockNativeResponder);\n};\n\nUIManager.clearJSResponder = () => {\n  RNGestureHandlerModule.handleClearJSResponder();\n  oldClearJSResponder();\n};\n\nvar handlerTag = 1;\nvar handlerIDToTag = {};\n\nfunction isConfigParam(param, name) {\n  return param !== undefined && (param !== Object(param) || !('__isNative' in param)) && name !== 'onHandlerStateChange' && name !== 'onGestureEvent';\n}\n\nfunction filterConfig(props, validProps) {\n  var defaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var res = _objectSpread({}, defaults);\n\n  Object.keys(validProps).forEach(key => {\n    var value = props[key];\n\n    if (isConfigParam(value, key)) {\n      var _value = props[key];\n\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\n        _value = transformIntoHandlerTags(props[key]);\n      } else if (key === 'hitSlop') {\n        if (typeof _value !== 'object') {\n          _value = {\n            top: _value,\n            left: _value,\n            bottom: _value,\n            right: _value\n          };\n        }\n      }\n\n      res[key] = _value;\n    }\n  });\n  return res;\n}\n\nfunction transformIntoHandlerTags(handlerIDs) {\n  if (!Array.isArray(handlerIDs)) {\n    handlerIDs = [handlerIDs];\n  }\n\n  if (Platform.OS === 'web') {\n    return handlerIDs.map((_ref) => {\n      var {\n        current\n      } = _ref;\n      return current;\n    }).filter(handle => handle);\n  }\n\n  return handlerIDs.map(handlerID => handlerIDToTag[handlerID] || handlerID.current && handlerID.current._handlerTag || -1).filter(handlerTag => handlerTag > 0);\n}\n\nfunction hasUnresolvedRefs(props) {\n  var extract = refs => {\n    if (!Array.isArray(refs)) {\n      return refs && refs.current === null;\n    }\n\n    return refs.some(r => r && r.current === null);\n  };\n\n  return extract(props['simultaneousHandlers']) || extract(props['waitFor']);\n}\n\nvar stateToPropMappings = {\n  [State.BEGAN]: 'onBegan',\n  [State.FAILED]: 'onFailed',\n  [State.CANCELLED]: 'onCancelled',\n  [State.ACTIVE]: 'onActivated',\n  [State.END]: 'onEnded'\n};\nexport default function createHandler(handlerName) {\n  var propTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var transformProps = arguments.length > 3 ? arguments[3] : undefined;\n  var customNativeProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  class Handler extends React.Component {\n    constructor(props) {\n      super(props);\n\n      this._onGestureHandlerEvent = event => {\n        if (event.nativeEvent.handlerTag === this._handlerTag) {\n          this.props.onGestureEvent && this.props.onGestureEvent(event);\n        } else {\n          this.props.onGestureHandlerEvent && this.props.onGestureHandlerEvent(event);\n        }\n      };\n\n      this._onGestureHandlerStateChange = event => {\n        if (event.nativeEvent.handlerTag === this._handlerTag) {\n          this.props.onHandlerStateChange && this.props.onHandlerStateChange(event);\n          var stateEventName = stateToPropMappings[event.nativeEvent.state];\n\n          if (typeof this.props[stateEventName] === 'function') {\n            this.props[stateEventName](event);\n          }\n        } else {\n          this.props.onGestureHandlerStateChange && this.props.onGestureHandlerStateChange(event);\n        }\n      };\n\n      this._refHandler = node => {\n        this._viewNode = node;\n        var child = React.Children.only(this.props.children);\n        var {\n          ref\n        } = child;\n\n        if (ref !== null) {\n          if (typeof ref === 'function') {\n            ref(node);\n          } else {\n            ref.current = node;\n          }\n        }\n      };\n\n      this._createGestureHandler = newConfig => {\n        this._config = newConfig;\n        RNGestureHandlerModule.createGestureHandler(handlerName, this._handlerTag, newConfig);\n      };\n\n      this._attachGestureHandler = newViewTag => {\n        this._viewTag = newViewTag;\n        RNGestureHandlerModule.attachGestureHandler(this._handlerTag, newViewTag);\n      };\n\n      this._updateGestureHandler = newConfig => {\n        this._config = newConfig;\n        RNGestureHandlerModule.updateGestureHandler(this._handlerTag, newConfig);\n      };\n\n      this._handlerTag = handlerTag++;\n      this._config = {};\n\n      if (props.id) {\n        if (handlerIDToTag[props.id] !== undefined) {\n          throw new Error(\"Handler with ID \\\"\".concat(props.id, \"\\\" already registered\"));\n        }\n\n        handlerIDToTag[props.id] = this._handlerTag;\n      }\n    }\n\n    componentWillUnmount() {\n      RNGestureHandlerModule.dropGestureHandler(this._handlerTag);\n\n      if (this._updateEnqueued) {\n        clearImmediate(this._updateEnqueued);\n      }\n\n      if (this.props.id) {\n        delete handlerIDToTag[this.props.id];\n      }\n    }\n\n    componentDidMount() {\n      if (hasUnresolvedRefs(this.props)) {\n        this._updateEnqueued = setImmediate(() => {\n          this._updateEnqueued = null;\n\n          this._update();\n        });\n      }\n\n      this._createGestureHandler(filterConfig(transformProps ? transformProps(this.props) : this.props, _objectSpread(_objectSpread({}, this.constructor.propTypes), customNativeProps), config));\n\n      this._attachGestureHandler(findNodeHandle(this._viewNode));\n    }\n\n    componentDidUpdate() {\n      var viewTag = findNodeHandle(this._viewNode);\n\n      if (this._viewTag !== viewTag) {\n        this._attachGestureHandler(viewTag);\n      }\n\n      this._update();\n    }\n\n    _update() {\n      var newConfig = filterConfig(transformProps ? transformProps(this.props) : this.props, _objectSpread(_objectSpread({}, this.constructor.propTypes), customNativeProps), config);\n\n      if (!deepEqual(this._config, newConfig)) {\n        this._updateGestureHandler(newConfig);\n      }\n    }\n\n    setNativeProps(updates) {\n      var mergedProps = _objectSpread(_objectSpread({}, this.props), updates);\n\n      var newConfig = filterConfig(transformProps ? transformProps(mergedProps) : mergedProps, _objectSpread(_objectSpread({}, this.constructor.propTypes), customNativeProps), config);\n\n      this._updateGestureHandler(newConfig);\n    }\n\n    render() {\n      var gestureEventHandler = this._onGestureHandlerEvent;\n      var {\n        onGestureEvent,\n        onGestureHandlerEvent\n      } = this.props;\n\n      if (onGestureEvent && typeof onGestureEvent !== 'function') {\n        if (onGestureHandlerEvent) {\n          throw new Error('Nesting touch handlers with native animated driver is not supported yet');\n        }\n\n        gestureEventHandler = this.props.onGestureEvent;\n      } else {\n        if (onGestureHandlerEvent && typeof onGestureHandlerEvent !== 'function') {\n          throw new Error('Nesting touch handlers with native animated driver is not supported yet');\n        }\n      }\n\n      var gestureStateEventHandler = this._onGestureHandlerStateChange;\n      var {\n        onHandlerStateChange,\n        onGestureHandlerStateChange\n      } = this.props;\n\n      if (onHandlerStateChange && typeof onHandlerStateChange !== 'function') {\n        if (onGestureHandlerStateChange) {\n          throw new Error('Nesting touch handlers with native animated driver is not supported yet');\n        }\n\n        gestureStateEventHandler = this.props.onHandlerStateChange;\n      } else {\n        if (onGestureHandlerStateChange && typeof onGestureHandlerStateChange !== 'function') {\n          throw new Error('Nesting touch handlers with native animated driver is not supported yet');\n        }\n      }\n\n      var child = React.Children.only(this.props.children);\n      var grandChildren = child.props.children;\n\n      if (Touchable.TOUCH_TARGET_DEBUG && child.type && (child.type === 'RNGestureHandlerButton' || child.type.name === 'View' || child.type.displayName === 'View')) {\n        grandChildren = React.Children.toArray(grandChildren);\n        grandChildren.push(Touchable.renderDebugView({\n          color: 'mediumspringgreen',\n          hitSlop: child.props.hitSlop\n        }));\n      }\n\n      return React.cloneElement(child, {\n        ref: this._refHandler,\n        collapsable: false,\n        onGestureHandlerEvent: gestureEventHandler,\n        onGestureHandlerStateChange: gestureStateEventHandler\n      }, grandChildren);\n    }\n\n  }\n\n  Handler.displayName = handlerName;\n  Handler.propTypes = propTypes;\n  return Handler;\n}","map":{"version":3,"sources":["/Users/m.asyam/Desktop/MY-PROJECTS/react-project/client-pack/node_modules/react-native-gesture-handler/createHandler.js"],"names":["React","deepEqual","RNGestureHandlerModule","State","findNodeHandle","node","Platform","OS","findNodeHandleRN","UIManager","NativeModules","customGHEventsConfig","onGestureHandlerEvent","registrationName","onGestureHandlerStateChange","genericDirectEventTypes","getConstants","setJSResponder","oldSetJSResponder","clearJSResponder","oldClearJSResponder","tag","blockNativeResponder","handleSetJSResponder","handleClearJSResponder","handlerTag","handlerIDToTag","isConfigParam","param","name","undefined","Object","filterConfig","props","validProps","defaults","res","keys","forEach","key","value","transformIntoHandlerTags","top","left","bottom","right","handlerIDs","Array","isArray","map","current","filter","handle","handlerID","_handlerTag","hasUnresolvedRefs","extract","refs","some","r","stateToPropMappings","BEGAN","FAILED","CANCELLED","ACTIVE","END","createHandler","handlerName","propTypes","config","transformProps","customNativeProps","Handler","Component","constructor","_onGestureHandlerEvent","event","nativeEvent","onGestureEvent","_onGestureHandlerStateChange","onHandlerStateChange","stateEventName","state","_refHandler","_viewNode","child","Children","only","children","ref","_createGestureHandler","newConfig","_config","createGestureHandler","_attachGestureHandler","newViewTag","_viewTag","attachGestureHandler","_updateGestureHandler","updateGestureHandler","id","Error","componentWillUnmount","dropGestureHandler","_updateEnqueued","clearImmediate","componentDidMount","setImmediate","_update","componentDidUpdate","viewTag","setNativeProps","updates","mergedProps","render","gestureEventHandler","gestureStateEventHandler","grandChildren","Touchable","TOUCH_TARGET_DEBUG","type","displayName","toArray","push","renderDebugView","color","hitSlop","cloneElement","collapsable"],"mappings":"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","sourcesContent":["import React from 'react';\nimport {\n  findNodeHandle as findNodeHandleRN,\n  NativeModules,\n  Touchable,\n  Platform,\n} from 'react-native';\nimport deepEqual from 'fbjs/lib/areEqual';\nimport RNGestureHandlerModule from './RNGestureHandlerModule';\nimport State from './State';\n\nfunction findNodeHandle(node) {\n  if (Platform.OS === 'web') return node;\n  return findNodeHandleRN(node);\n}\n\nconst { UIManager = {} } = NativeModules;\n\nconst customGHEventsConfig = {\n  onGestureHandlerEvent: { registrationName: 'onGestureHandlerEvent' },\n  onGestureHandlerStateChange: {\n    registrationName: 'onGestureHandlerStateChange',\n  },\n};\n\n// Add gesture specific events to genericDirectEventTypes object exported from UIManager\n// native module.\n// Once new event types are registered with react it is possible to dispatch these\n// events to all kind of native views.\nUIManager.genericDirectEventTypes = {\n  ...UIManager.genericDirectEventTypes,\n  ...customGHEventsConfig,\n};\n// In newer versions of RN the `genericDirectEventTypes` is located in the object\n// returned by UIManager.getConstants(), we need to add it there as well to make\n// it compatible with RN 61+\nif (UIManager.getConstants) {\n  UIManager.getConstants().genericDirectEventTypes = {\n    ...UIManager.getConstants().genericDirectEventTypes,\n    ...customGHEventsConfig,\n  };\n}\n\n// Wrap JS responder calls and notify gesture handler manager\nconst {\n  setJSResponder: oldSetJSResponder = () => {},\n  clearJSResponder: oldClearJSResponder = () => {},\n} = UIManager;\nUIManager.setJSResponder = (tag, blockNativeResponder) => {\n  RNGestureHandlerModule.handleSetJSResponder(tag, blockNativeResponder);\n  oldSetJSResponder(tag, blockNativeResponder);\n};\nUIManager.clearJSResponder = () => {\n  RNGestureHandlerModule.handleClearJSResponder();\n  oldClearJSResponder();\n};\n\nlet handlerTag = 1;\nconst handlerIDToTag = {};\n\nfunction isConfigParam(param, name) {\n  // param !== Object(param) returns false if `param` is a function\n  // or an object and returns true if `param` is null\n  return (\n    param !== undefined &&\n    (param !== Object(param) || !('__isNative' in param)) &&\n    name !== 'onHandlerStateChange' &&\n    name !== 'onGestureEvent'\n  );\n}\n\nfunction filterConfig(props, validProps, defaults = {}) {\n  const res = { ...defaults };\n  Object.keys(validProps).forEach(key => {\n    const value = props[key];\n    if (isConfigParam(value, key)) {\n      let value = props[key];\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\n        value = transformIntoHandlerTags(props[key]);\n      } else if (key === 'hitSlop') {\n        if (typeof value !== 'object') {\n          value = { top: value, left: value, bottom: value, right: value };\n        }\n      }\n      res[key] = value;\n    }\n  });\n  return res;\n}\n\nfunction transformIntoHandlerTags(handlerIDs) {\n  if (!Array.isArray(handlerIDs)) {\n    handlerIDs = [handlerIDs];\n  }\n\n  if (Platform.OS === 'web') {\n    return handlerIDs.map(({ current }) => current).filter(handle => handle);\n  }\n  // converts handler string IDs into their numeric tags\n  return handlerIDs\n    .map(\n      handlerID =>\n        handlerIDToTag[handlerID] ||\n        (handlerID.current && handlerID.current._handlerTag) ||\n        -1\n    )\n    .filter(handlerTag => handlerTag > 0);\n}\n\nfunction hasUnresolvedRefs(props) {\n  const extract = refs => {\n    if (!Array.isArray(refs)) {\n      return refs && refs.current === null;\n    }\n    return refs.some(r => r && r.current === null);\n  };\n  return extract(props['simultaneousHandlers']) || extract(props['waitFor']);\n}\n\nconst stateToPropMappings = {\n  [State.BEGAN]: 'onBegan',\n  [State.FAILED]: 'onFailed',\n  [State.CANCELLED]: 'onCancelled',\n  [State.ACTIVE]: 'onActivated',\n  [State.END]: 'onEnded',\n};\n\nexport default function createHandler(\n  handlerName,\n  propTypes = {},\n  config = {},\n  transformProps,\n  customNativeProps = {}\n) {\n  class Handler extends React.Component {\n    static displayName = handlerName;\n\n    static propTypes = propTypes;\n\n    constructor(props) {\n      super(props);\n      this._handlerTag = handlerTag++;\n      this._config = {};\n      if (props.id) {\n        if (handlerIDToTag[props.id] !== undefined) {\n          throw new Error(`Handler with ID \"${props.id}\" already registered`);\n        }\n        handlerIDToTag[props.id] = this._handlerTag;\n      }\n    }\n\n    _onGestureHandlerEvent = event => {\n      if (event.nativeEvent.handlerTag === this._handlerTag) {\n        this.props.onGestureEvent && this.props.onGestureEvent(event);\n      } else {\n        this.props.onGestureHandlerEvent &&\n          this.props.onGestureHandlerEvent(event);\n      }\n    };\n\n    _onGestureHandlerStateChange = event => {\n      if (event.nativeEvent.handlerTag === this._handlerTag) {\n        this.props.onHandlerStateChange &&\n          this.props.onHandlerStateChange(event);\n\n        const stateEventName = stateToPropMappings[event.nativeEvent.state];\n        if (typeof this.props[stateEventName] === 'function') {\n          this.props[stateEventName](event);\n        }\n      } else {\n        this.props.onGestureHandlerStateChange &&\n          this.props.onGestureHandlerStateChange(event);\n      }\n    };\n\n    _refHandler = node => {\n      this._viewNode = node;\n\n      const child = React.Children.only(this.props.children);\n      const { ref } = child;\n      if (ref !== null) {\n        if (typeof ref === 'function') {\n          ref(node);\n        } else {\n          ref.current = node;\n        }\n      }\n    };\n\n    _createGestureHandler = newConfig => {\n      this._config = newConfig;\n\n      RNGestureHandlerModule.createGestureHandler(\n        handlerName,\n        this._handlerTag,\n        newConfig\n      );\n    };\n\n    _attachGestureHandler = newViewTag => {\n      this._viewTag = newViewTag;\n\n      RNGestureHandlerModule.attachGestureHandler(this._handlerTag, newViewTag);\n    };\n\n    _updateGestureHandler = newConfig => {\n      this._config = newConfig;\n\n      RNGestureHandlerModule.updateGestureHandler(this._handlerTag, newConfig);\n    };\n\n    componentWillUnmount() {\n      RNGestureHandlerModule.dropGestureHandler(this._handlerTag);\n      if (this._updateEnqueued) {\n        clearImmediate(this._updateEnqueued);\n      }\n      if (this.props.id) {\n        delete handlerIDToTag[this.props.id];\n      }\n    }\n\n    componentDidMount() {\n      if (hasUnresolvedRefs(this.props)) {\n        // If there are unresolved refs (e.g. \".current\" has not yet been set)\n        // passed as `simultaneousHandlers` or `waitFor`, we enqueue a call to\n        // _update method that will try to update native handler props using\n        // setImmediate. This makes it so _update function gets called after all\n        // react components are mounted and we expect the missing ref object to\n        // be resolved by then.\n        this._updateEnqueued = setImmediate(() => {\n          this._updateEnqueued = null;\n          this._update();\n        });\n      }\n\n      this._createGestureHandler(\n        filterConfig(\n          transformProps ? transformProps(this.props) : this.props,\n          { ...this.constructor.propTypes, ...customNativeProps },\n          config\n        )\n      );\n      this._attachGestureHandler(findNodeHandle(this._viewNode));\n    }\n\n    componentDidUpdate() {\n      const viewTag = findNodeHandle(this._viewNode);\n      if (this._viewTag !== viewTag) {\n        this._attachGestureHandler(viewTag);\n      }\n      this._update();\n    }\n\n    _update() {\n      const newConfig = filterConfig(\n        transformProps ? transformProps(this.props) : this.props,\n        { ...this.constructor.propTypes, ...customNativeProps },\n        config\n      );\n      if (!deepEqual(this._config, newConfig)) {\n        this._updateGestureHandler(newConfig);\n      }\n    }\n\n    setNativeProps(updates) {\n      const mergedProps = { ...this.props, ...updates };\n      const newConfig = filterConfig(\n        transformProps ? transformProps(mergedProps) : mergedProps,\n        { ...this.constructor.propTypes, ...customNativeProps },\n        config\n      );\n      this._updateGestureHandler(newConfig);\n    }\n\n    render() {\n      let gestureEventHandler = this._onGestureHandlerEvent;\n      const { onGestureEvent, onGestureHandlerEvent } = this.props;\n      if (onGestureEvent && typeof onGestureEvent !== 'function') {\n        // If it's not a method it should be an native Animated.event\n        // object. We set it directly as the handler for the view\n        // In this case nested handlers are not going to be supported\n        if (onGestureHandlerEvent) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n        gestureEventHandler = this.props.onGestureEvent;\n      } else {\n        if (\n          onGestureHandlerEvent &&\n          typeof onGestureHandlerEvent !== 'function'\n        ) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n      }\n\n      let gestureStateEventHandler = this._onGestureHandlerStateChange;\n      const { onHandlerStateChange, onGestureHandlerStateChange } = this.props;\n      if (onHandlerStateChange && typeof onHandlerStateChange !== 'function') {\n        // If it's not a method it should be an native Animated.event\n        // object. We set it directly as the handler for the view\n        // In this case nested handlers are not going to be supported\n        if (onGestureHandlerStateChange) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n        gestureStateEventHandler = this.props.onHandlerStateChange;\n      } else {\n        if (\n          onGestureHandlerStateChange &&\n          typeof onGestureHandlerStateChange !== 'function'\n        ) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n      }\n\n      const child = React.Children.only(this.props.children);\n      let grandChildren = child.props.children;\n      if (\n        Touchable.TOUCH_TARGET_DEBUG &&\n        child.type &&\n        (child.type === 'RNGestureHandlerButton' ||\n          child.type.name === 'View' ||\n          child.type.displayName === 'View')\n      ) {\n        grandChildren = React.Children.toArray(grandChildren);\n        grandChildren.push(\n          Touchable.renderDebugView({\n            color: 'mediumspringgreen',\n            hitSlop: child.props.hitSlop,\n          })\n        );\n      }\n      return React.cloneElement(\n        child,\n        {\n          ref: this._refHandler,\n          collapsable: false,\n          onGestureHandlerEvent: gestureEventHandler,\n          onGestureHandlerStateChange: gestureStateEventHandler,\n        },\n        grandChildren\n      );\n    }\n  }\n  return Handler;\n}\n"]},"metadata":{},"sourceType":"module"}