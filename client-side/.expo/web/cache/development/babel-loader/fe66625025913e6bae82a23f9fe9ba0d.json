{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport { SceneView, ThemeColors, ThemeContext } from 'react-navigation';\nimport { ScreenContainer } from 'react-native-screens';\nimport * as DrawerActions from \"../routers/DrawerActions\";\nimport DrawerSidebar from \"./DrawerSidebar\";\nimport DrawerGestureContext from \"../utils/DrawerGestureContext\";\nimport ResourceSavingScene from \"./ResourceSavingScene\";\nimport Drawer from \"./Drawer\";\nexport default class DrawerView extends React.PureComponent {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"state\", {\n      loaded: [this.props.navigation.state.index],\n      drawerWidth: typeof this.props.navigationConfig.drawerWidth === 'function' ? this.props.navigationConfig.drawerWidth() : this.props.navigationConfig.drawerWidth\n    });\n\n    _defineProperty(this, \"context\", void 0);\n\n    _defineProperty(this, \"drawerGestureRef\", React.createRef());\n\n    _defineProperty(this, \"getLockMode\", (_ref) => {\n      var {\n        navigation,\n        descriptors\n      } = _ref;\n      var activeKey = navigation.state.routes[navigation.state.index].key;\n      var {\n        drawerLockMode\n      } = descriptors[activeKey].options;\n      return drawerLockMode;\n    });\n\n    _defineProperty(this, \"handleDrawerOpen\", () => {\n      var {\n        navigation\n      } = this.props;\n      navigation.dispatch(DrawerActions.openDrawer({\n        key: navigation.state.key\n      }));\n    });\n\n    _defineProperty(this, \"handleDrawerClose\", () => {\n      var {\n        navigation\n      } = this.props;\n      navigation.dispatch(DrawerActions.closeDrawer({\n        key: navigation.state.key\n      }));\n    });\n\n    _defineProperty(this, \"updateWidth\", () => {\n      var drawerWidth = typeof this.props.navigationConfig.drawerWidth === 'function' ? this.props.navigationConfig.drawerWidth() : this.props.navigationConfig.drawerWidth;\n\n      if (this.state.drawerWidth !== drawerWidth) {\n        this.setState({\n          drawerWidth\n        });\n      }\n    });\n\n    _defineProperty(this, \"renderNavigationView\", (_ref2) => {\n      var {\n        progress\n      } = _ref2;\n      return React.createElement(DrawerSidebar, _extends({\n        screenProps: this.props.screenProps,\n        drawerOpenProgress: progress,\n        navigation: this.props.navigation,\n        descriptors: this.props.descriptors,\n        contentComponent: this.props.navigationConfig.contentComponent,\n        contentOptions: this.props.navigationConfig.contentOptions,\n        drawerPosition: this.props.navigationConfig.drawerPosition,\n        style: this.props.navigationConfig.style\n      }, this.props.navigationConfig));\n    });\n\n    _defineProperty(this, \"renderContent\", () => {\n      var {\n        lazy,\n        navigation\n      } = this.props;\n      var {\n        loaded\n      } = this.state;\n      var {\n        routes\n      } = navigation.state;\n\n      if (this.props.navigationConfig.unmountInactiveRoutes) {\n        var activeKey = navigation.state.routes[navigation.state.index].key;\n        var descriptor = this.props.descriptors[activeKey];\n        return React.createElement(SceneView, {\n          navigation: descriptor.navigation,\n          screenProps: this.props.screenProps,\n          component: descriptor.getComponent()\n        });\n      } else {\n        return React.createElement(ScreenContainer, {\n          style: styles.content\n        }, routes.map((route, index) => {\n          if (lazy && !loaded.includes(index)) {\n            return null;\n          }\n\n          var isFocused = navigation.state.index === index;\n          var descriptor = this.props.descriptors[route.key];\n          return React.createElement(ResourceSavingScene, {\n            key: route.key,\n            style: [StyleSheet.absoluteFill, {\n              opacity: isFocused ? 1 : 0\n            }],\n            isVisible: isFocused\n          }, React.createElement(SceneView, {\n            navigation: descriptor.navigation,\n            screenProps: this.props.screenProps,\n            component: descriptor.getComponent()\n          }));\n        }));\n      }\n    });\n\n    _defineProperty(this, \"setDrawerGestureRef\", ref => {\n      this.drawerGestureRef.current = ref;\n    });\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    var {\n      index\n    } = nextProps.navigation.state;\n    return {\n      loaded: prevState.loaded.includes(index) ? prevState.loaded : [...prevState.loaded, index]\n    };\n  }\n\n  componentDidMount() {\n    if (this.getLockMode(this.props) === 'locked-open') {\n      this.handleDrawerOpen();\n    }\n\n    Dimensions.addEventListener('change', this.updateWidth);\n  }\n\n  componentDidUpdate(prevProps) {\n    var prevLockMode = this.getLockMode(prevProps);\n    var nextLockMode = this.getLockMode(this.props);\n\n    if (prevLockMode !== nextLockMode) {\n      if (nextLockMode === 'locked-open') {\n        this.handleDrawerOpen();\n      } else {\n        this.handleDrawerClose();\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    Dimensions.removeEventListener('change', this.updateWidth);\n  }\n\n  getDrawerBackgroundColor() {\n    var {\n      drawerBackgroundColor\n    } = this.props.navigationConfig;\n\n    if (drawerBackgroundColor) {\n      return typeof drawerBackgroundColor === 'string' ? drawerBackgroundColor : drawerBackgroundColor[this.context];\n    } else {\n      return ThemeColors[this.context].bodyContent;\n    }\n  }\n\n  getOverlayColor() {\n    var {\n      overlayColor\n    } = this.props.navigationConfig;\n\n    if (overlayColor) {\n      return typeof overlayColor === 'string' ? overlayColor : overlayColor[this.context];\n    } else {\n      return 'rgba(0,0,0,0.5)';\n    }\n  }\n\n  render() {\n    var {\n      navigation,\n      navigationConfig\n    } = this.props;\n    var {\n      drawerType,\n      sceneContainerStyle,\n      edgeWidth,\n      minSwipeDistance,\n      hideStatusBar,\n      statusBarAnimation,\n      gestureHandlerProps\n    } = navigationConfig;\n    var drawerLockMode = this.getLockMode(this.props);\n    var drawerBackgroundColor = this.getDrawerBackgroundColor();\n    var overlayColor = this.getOverlayColor();\n    return React.createElement(DrawerGestureContext.Provider, {\n      value: this.drawerGestureRef\n    }, React.createElement(Drawer, {\n      open: navigation.state.isDrawerOpen,\n      gestureEnabled: drawerLockMode !== 'locked-open' && drawerLockMode !== 'locked-closed',\n      onOpen: this.handleDrawerOpen,\n      onClose: this.handleDrawerClose,\n      onGestureRef: this.setDrawerGestureRef,\n      gestureHandlerProps: gestureHandlerProps,\n      drawerType: drawerType,\n      drawerPosition: this.props.navigationConfig.drawerPosition,\n      sceneContainerStyle: sceneContainerStyle,\n      drawerStyle: {\n        backgroundColor: drawerBackgroundColor,\n        width: this.state.drawerWidth\n      },\n      overlayStyle: {\n        backgroundColor: overlayColor\n      },\n      swipeEdgeWidth: edgeWidth,\n      swipeDistanceThreshold: minSwipeDistance,\n      hideStatusBar: hideStatusBar,\n      statusBarAnimation: statusBarAnimation,\n      renderDrawerContent: this.renderNavigationView,\n      renderSceneContent: this.renderContent\n    }));\n  }\n\n}\n\n_defineProperty(DrawerView, \"contextType\", ThemeContext);\n\n_defineProperty(DrawerView, \"defaultProps\", {\n  lazy: true\n});\n\nvar styles = StyleSheet.create({\n  content: {\n    flex: 1\n  }\n});","map":{"version":3,"sources":["DrawerView.tsx"],"names":["DrawerView","React","ThemeContext","lazy","index","nextProps","loaded","prevState","drawerWidth","componentDidMount","Dimensions","componentDidUpdate","prevLockMode","nextLockMode","componentWillUnmount","descriptors","activeKey","navigation","drawerLockMode","key","progress","style","routes","descriptor","styles","content","isFocused","route","StyleSheet","opacity","ref","getDrawerBackgroundColor","drawerBackgroundColor","ThemeColors","getOverlayColor","overlayColor","render","navigationConfig","gestureHandlerProps","drawerGestureRef","backgroundColor","width","renderContent","flex"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Dimensions, StyleSheet, ViewStyle } from 'react-native';\nimport {\n  SceneView,\n  ThemeColors,\n  ThemeContext,\n  NavigationScreenProp,\n} from 'react-navigation';\nimport { ScreenContainer } from 'react-native-screens';\n\nimport * as DrawerActions from '../routers/DrawerActions';\nimport DrawerSidebar from './DrawerSidebar';\nimport DrawerGestureContext from '../utils/DrawerGestureContext';\nimport ResourceSavingScene from './ResourceSavingScene';\nimport Drawer from './Drawer';\nimport {\n  NavigationDrawerState,\n  DrawerContentComponentProps,\n  SceneDescriptorMap,\n} from '../types';\nimport { PanGestureHandler } from 'react-native-gesture-handler';\n\ntype DrawerOptions = {\n  drawerBackgroundColor?: string;\n  overlayColor?: string;\n  minSwipeDistance?: number;\n  drawerPosition: 'left' | 'right';\n  drawerType: 'front' | 'back' | 'slide';\n  drawerLockMode?: 'unlocked' | 'locked-closed' | 'locked-open';\n  keyboardDismissMode?: 'on-drag' | 'none';\n  drawerWidth: number | (() => number);\n  statusBarAnimation: 'slide' | 'none' | 'fade';\n  onDrawerClose?: () => void;\n  onDrawerOpen?: () => void;\n  sceneContainerStyle?: ViewStyle;\n  edgeWidth: number;\n  hideStatusBar?: boolean;\n  style?: ViewStyle;\n  gestureHandlerProps?: React.ComponentProps<typeof PanGestureHandler>;\n};\n\ntype Props = {\n  lazy: boolean;\n  navigation: NavigationScreenProp<NavigationDrawerState>;\n  descriptors: SceneDescriptorMap;\n  navigationConfig: DrawerOptions & {\n    contentComponent?: React.ComponentType<DrawerContentComponentProps>;\n    unmountInactiveRoutes?: boolean;\n    contentOptions?: object;\n  };\n  screenProps: unknown;\n};\n\ntype State = {\n  loaded: number[];\n  drawerWidth: number;\n};\n\n/**\n * Component that renders the drawer.\n */\nexport default class DrawerView extends React.PureComponent<Props, State> {\n  // eslint-disable-next-line react/sort-comp\n  static contextType = ThemeContext;\n  static defaultProps = {\n    lazy: true,\n  };\n\n  static getDerivedStateFromProps(nextProps: Props, prevState: State) {\n    const { index } = nextProps.navigation.state;\n\n    return {\n      // Set the current tab to be loaded if it was not loaded before\n      loaded: prevState.loaded.includes(index)\n        ? prevState.loaded\n        : [...prevState.loaded, index],\n    };\n  }\n\n  state: State = {\n    loaded: [this.props.navigation.state.index],\n    drawerWidth:\n      typeof this.props.navigationConfig.drawerWidth === 'function'\n        ? this.props.navigationConfig.drawerWidth()\n        : this.props.navigationConfig.drawerWidth,\n  };\n\n  componentDidMount() {\n    // If drawerLockMode was set to `locked-open`, we should open the drawer on mount\n    if (this.getLockMode(this.props) === 'locked-open') {\n      this.handleDrawerOpen();\n    }\n\n    Dimensions.addEventListener('change', this.updateWidth);\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    const prevLockMode = this.getLockMode(prevProps);\n    const nextLockMode = this.getLockMode(this.props);\n\n    if (prevLockMode !== nextLockMode) {\n      if (nextLockMode === 'locked-open') {\n        this.handleDrawerOpen();\n      } else {\n        this.handleDrawerClose();\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    Dimensions.removeEventListener('change', this.updateWidth);\n  }\n\n  context!: React.ContextType<typeof ThemeContext>;\n\n  private drawerGestureRef = React.createRef<PanGestureHandler>();\n\n  private getLockMode = ({ navigation, descriptors }: Props) => {\n    const activeKey = navigation.state.routes[navigation.state.index].key;\n    const { drawerLockMode } = descriptors[activeKey].options;\n\n    return drawerLockMode;\n  };\n\n  private handleDrawerOpen = () => {\n    const { navigation } = this.props;\n\n    navigation.dispatch(\n      DrawerActions.openDrawer({\n        key: navigation.state.key,\n      })\n    );\n  };\n\n  private handleDrawerClose = () => {\n    const { navigation } = this.props;\n\n    navigation.dispatch(\n      DrawerActions.closeDrawer({\n        key: navigation.state.key,\n      })\n    );\n  };\n\n  private updateWidth = () => {\n    const drawerWidth =\n      typeof this.props.navigationConfig.drawerWidth === 'function'\n        ? this.props.navigationConfig.drawerWidth()\n        : this.props.navigationConfig.drawerWidth;\n\n    if (this.state.drawerWidth !== drawerWidth) {\n      this.setState({ drawerWidth });\n    }\n  };\n\n  private renderNavigationView = ({ progress }: any) => {\n    return (\n      <DrawerSidebar\n        screenProps={this.props.screenProps}\n        drawerOpenProgress={progress}\n        navigation={this.props.navigation}\n        descriptors={this.props.descriptors}\n        contentComponent={this.props.navigationConfig.contentComponent}\n        contentOptions={this.props.navigationConfig.contentOptions}\n        drawerPosition={this.props.navigationConfig.drawerPosition}\n        style={this.props.navigationConfig.style}\n        {...this.props.navigationConfig}\n      />\n    );\n  };\n\n  private renderContent = () => {\n    let { lazy, navigation } = this.props;\n    let { loaded } = this.state;\n    let { routes } = navigation.state;\n\n    if (this.props.navigationConfig.unmountInactiveRoutes) {\n      let activeKey = navigation.state.routes[navigation.state.index].key;\n      let descriptor = this.props.descriptors[activeKey];\n\n      return (\n        <SceneView\n          navigation={descriptor.navigation}\n          screenProps={this.props.screenProps}\n          component={descriptor.getComponent()}\n        />\n      );\n    } else {\n      return (\n        <ScreenContainer style={styles.content}>\n          {routes.map((route, index) => {\n            if (lazy && !loaded.includes(index)) {\n              // Don't render a screen if we've never navigated to it\n              return null;\n            }\n\n            let isFocused = navigation.state.index === index;\n            let descriptor = this.props.descriptors[route.key];\n\n            return (\n              <ResourceSavingScene\n                key={route.key}\n                style={[\n                  StyleSheet.absoluteFill,\n                  { opacity: isFocused ? 1 : 0 },\n                ]}\n                isVisible={isFocused}\n              >\n                <SceneView\n                  navigation={descriptor.navigation}\n                  screenProps={this.props.screenProps}\n                  component={descriptor.getComponent()}\n                />\n              </ResourceSavingScene>\n            );\n          })}\n        </ScreenContainer>\n      );\n    }\n  };\n\n  private setDrawerGestureRef = (ref: PanGestureHandler | null) => {\n    // @ts-ignore\n    this.drawerGestureRef.current = ref;\n  };\n\n  private getDrawerBackgroundColor() {\n    const { drawerBackgroundColor } = this.props.navigationConfig;\n\n    if (drawerBackgroundColor) {\n      return typeof drawerBackgroundColor === 'string'\n        ? drawerBackgroundColor\n        : drawerBackgroundColor[this.context];\n    } else {\n      return ThemeColors[this.context].bodyContent;\n    }\n  }\n\n  private getOverlayColor() {\n    const { overlayColor } = this.props.navigationConfig;\n\n    if (overlayColor) {\n      return typeof overlayColor === 'string'\n        ? overlayColor\n        : overlayColor[this.context];\n    } else {\n      return 'rgba(0,0,0,0.5)';\n    }\n  }\n\n  render() {\n    const { navigation, navigationConfig } = this.props;\n    const {\n      drawerType,\n      sceneContainerStyle,\n      edgeWidth,\n      minSwipeDistance,\n      hideStatusBar,\n      statusBarAnimation,\n      gestureHandlerProps,\n    } = navigationConfig;\n\n    const drawerLockMode = this.getLockMode(this.props);\n    const drawerBackgroundColor = this.getDrawerBackgroundColor();\n    const overlayColor = this.getOverlayColor();\n\n    return (\n      <DrawerGestureContext.Provider value={this.drawerGestureRef}>\n        <Drawer\n          open={navigation.state.isDrawerOpen}\n          gestureEnabled={\n            drawerLockMode !== 'locked-open' &&\n            drawerLockMode !== 'locked-closed'\n          }\n          onOpen={this.handleDrawerOpen}\n          onClose={this.handleDrawerClose}\n          onGestureRef={this.setDrawerGestureRef}\n          gestureHandlerProps={gestureHandlerProps}\n          drawerType={drawerType}\n          drawerPosition={this.props.navigationConfig.drawerPosition}\n          sceneContainerStyle={sceneContainerStyle}\n          drawerStyle={{\n            backgroundColor: drawerBackgroundColor,\n            width: this.state.drawerWidth,\n          }}\n          overlayStyle={{ backgroundColor: overlayColor }}\n          swipeEdgeWidth={edgeWidth}\n          swipeDistanceThreshold={minSwipeDistance}\n          hideStatusBar={hideStatusBar}\n          statusBarAnimation={statusBarAnimation}\n          renderDrawerContent={this.renderNavigationView}\n          renderSceneContent={this.renderContent}\n        />\n      </DrawerGestureContext.Provider>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  content: {\n    flex: 1,\n  },\n});\n"]},"metadata":{},"sourceType":"module"}