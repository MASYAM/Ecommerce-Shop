{"ast":null,"code":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport Hammer from '@egjs/hammerjs';\nimport { Direction } from \"./constants\";\nimport { GesturePropError } from \"./Errors\";\nimport DraggingGestureHandler from \"./DraggingGestureHandler\";\nimport { isnan } from \"./utils\";\n\nclass FlingGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'swipe';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Swipe;\n  }\n\n  onGestureActivated(event) {\n    this.sendEvent(_objectSpread(_objectSpread({}, event), {}, {\n      eventType: Hammer.INPUT_MOVE,\n      isFinal: false,\n      isFirst: true\n    }));\n    this.isGestureRunning = false;\n    this.hasGestureFailed = false;\n    this.sendEvent(_objectSpread(_objectSpread({}, event), {}, {\n      eventType: Hammer.INPUT_END,\n      isFinal: true\n    }));\n  }\n\n  onRawEvent(ev) {\n    super.onRawEvent(ev);\n\n    if (this.hasGestureFailed) {\n      return;\n    }\n\n    if (ev.isFinal) {\n      setTimeout(() => {\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      var gesture = this.hammer.get(this.name);\n\n      if (gesture.options.enable(gesture, ev)) {\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      pointers: this.config.numberOfPointers,\n      direction: this.getDirection()\n    };\n  }\n\n  getTargetDirections(direction) {\n    var directions = [];\n\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_RIGHT);\n    }\n\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_LEFT);\n    }\n\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_UP);\n    }\n\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_DOWN);\n    }\n\n    return directions;\n  }\n\n  getDirection() {\n    var {\n      direction\n    } = this.getConfig();\n    var directions = [];\n\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n\n    directions = [...new Set(directions)];\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\n    if (directions.length === 1) return directions[0];\n    return Hammer.DIRECTION_ALL;\n  }\n\n  isGestureEnabledForEvent(_ref, recognizer, _ref2) {\n    var {\n      minPointers,\n      maxPointers,\n      numberOfPointers,\n      maxDist,\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside\n    } = _ref;\n\n    var {\n      maxPointers: pointerLength,\n      deltaX: dx,\n      deltaY: dy\n    } = _ref2,\n        props = _objectWithoutProperties(_ref2, [\"maxPointers\", \"deltaX\", \"deltaY\"]);\n\n    var validPointerCount = pointerLength === numberOfPointers;\n\n    if (!validPointerCount && this.isGestureRunning) {\n      return {\n        failed: true\n      };\n    }\n\n    return {\n      success: validPointerCount\n    };\n  }\n\n  updateGestureConfig(_ref3) {\n    var {\n      numberOfPointers = 1,\n      direction\n    } = _ref3,\n        props = _objectWithoutProperties(_ref3, [\"numberOfPointers\", \"direction\"]);\n\n    if (isnan(direction) || typeof direction !== 'number') {\n      throw new GesturePropError('direction', direction, 'number');\n    }\n\n    return super.updateGestureConfig(_objectSpread({\n      numberOfPointers,\n      direction\n    }, props));\n  }\n\n}\n\nexport default FlingGestureHandler;","map":{"version":3,"sources":["/Users/m.asyam/Desktop/MY-PROJECTS/react-project/client-pack/node_modules/react-native-gesture-handler/web/FlingGestureHandler.js"],"names":["Hammer","Direction","GesturePropError","DraggingGestureHandler","isnan","FlingGestureHandler","name","NativeGestureClass","Swipe","onGestureActivated","event","sendEvent","eventType","INPUT_MOVE","isFinal","isFirst","isGestureRunning","hasGestureFailed","INPUT_END","onRawEvent","ev","setTimeout","cancelEvent","gesture","hammer","get","options","enable","onStart","getHammerConfig","pointers","config","numberOfPointers","direction","getDirection","getTargetDirections","directions","RIGHT","push","DIRECTION_RIGHT","LEFT","DIRECTION_LEFT","UP","DIRECTION_UP","DOWN","DIRECTION_DOWN","getConfig","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","Set","length","DIRECTION_NONE","DIRECTION_ALL","isGestureEnabledForEvent","recognizer","minPointers","maxPointers","maxDist","maxDeltaX","maxDeltaY","maxDistSq","shouldCancelWhenOutside","pointerLength","deltaX","dx","deltaY","dy","props","validPointerCount","failed","success","updateGestureConfig"],"mappings":";;;;;;;;;;AAAA,OAAOA,MAAP,MAAmB,gBAAnB;AAEA,SAASC,SAAT;AACA,SAASC,gBAAT;AACA,OAAOC,sBAAP;AACA,SAASC,KAAT;;AAEA,MAAMC,mBAAN,SAAkCF,sBAAlC,CAAyD;AACvD,MAAIG,IAAJ,GAAW;AACT,WAAO,OAAP;AACD;;AAED,MAAIC,kBAAJ,GAAyB;AACvB,WAAOP,MAAM,CAACQ,KAAd;AACD;;AAEDC,EAAAA,kBAAkB,CAACC,KAAD,EAAQ;AACxB,SAAKC,SAAL,iCACKD,KADL;AAEEE,MAAAA,SAAS,EAAEZ,MAAM,CAACa,UAFpB;AAGEC,MAAAA,OAAO,EAAE,KAHX;AAIEC,MAAAA,OAAO,EAAE;AAJX;AAMA,SAAKC,gBAAL,GAAwB,KAAxB;AACA,SAAKC,gBAAL,GAAwB,KAAxB;AACA,SAAKN,SAAL,iCACKD,KADL;AAEEE,MAAAA,SAAS,EAAEZ,MAAM,CAACkB,SAFpB;AAGEJ,MAAAA,OAAO,EAAE;AAHX;AAKD;;AAEDK,EAAAA,UAAU,CAACC,EAAD,EAAK;AACb,UAAMD,UAAN,CAAiBC,EAAjB;;AACA,QAAI,KAAKH,gBAAT,EAA2B;AACzB;AACD;;AAGD,QAAIG,EAAE,CAACN,OAAP,EAAgB;AACdO,MAAAA,UAAU,CAAC,MAAM;AACf,YAAI,KAAKL,gBAAT,EAA2B;AACzB,eAAKM,WAAL,CAAiBF,EAAjB;AACD;AACF,OAJS,CAAV;AAKD,KAND,MAMO,IAAI,CAAC,KAAKH,gBAAN,IAA0B,CAAC,KAAKD,gBAApC,EAAsD;AAE3D,UAAMO,OAAO,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgB,KAAKnB,IAArB,CAAhB;;AACA,UAAIiB,OAAO,CAACG,OAAR,CAAgBC,MAAhB,CAAuBJ,OAAvB,EAAgCH,EAAhC,CAAJ,EAAyC;AACvC,aAAKQ,OAAL,CAAaR,EAAb;AACA,aAAKT,SAAL,CAAeS,EAAf;AACD;AACF;AACF;;AAEDS,EAAAA,eAAe,GAAG;AAChB,WAAO;AACLC,MAAAA,QAAQ,EAAE,KAAKC,MAAL,CAAYC,gBADjB;AAELC,MAAAA,SAAS,EAAE,KAAKC,YAAL;AAFN,KAAP;AAID;;AAEDC,EAAAA,mBAAmB,CAACF,SAAD,EAAY;AAC7B,QAAMG,UAAU,GAAG,EAAnB;;AACA,QAAIH,SAAS,GAAGhC,SAAS,CAACoC,KAA1B,EAAiC;AAC/BD,MAAAA,UAAU,CAACE,IAAX,CAAgBtC,MAAM,CAACuC,eAAvB;AACD;;AACD,QAAIN,SAAS,GAAGhC,SAAS,CAACuC,IAA1B,EAAgC;AAC9BJ,MAAAA,UAAU,CAACE,IAAX,CAAgBtC,MAAM,CAACyC,cAAvB;AACD;;AACD,QAAIR,SAAS,GAAGhC,SAAS,CAACyC,EAA1B,EAA8B;AAC5BN,MAAAA,UAAU,CAACE,IAAX,CAAgBtC,MAAM,CAAC2C,YAAvB;AACD;;AACD,QAAIV,SAAS,GAAGhC,SAAS,CAAC2C,IAA1B,EAAgC;AAC9BR,MAAAA,UAAU,CAACE,IAAX,CAAgBtC,MAAM,CAAC6C,cAAvB;AACD;;AAED,WAAOT,UAAP;AACD;;AAEDF,EAAAA,YAAY,GAAG;AACb,QAAM;AAAED,MAAAA;AAAF,QAAgB,KAAKa,SAAL,EAAtB;AAEA,QAAIV,UAAU,GAAG,EAAjB;;AACA,QAAIH,SAAS,GAAGhC,SAAS,CAACoC,KAA1B,EAAiC;AAC/BD,MAAAA,UAAU,CAACE,IAAX,CAAgBtC,MAAM,CAAC+C,oBAAvB;AACD;;AACD,QAAId,SAAS,GAAGhC,SAAS,CAACuC,IAA1B,EAAgC;AAC9BJ,MAAAA,UAAU,CAACE,IAAX,CAAgBtC,MAAM,CAAC+C,oBAAvB;AACD;;AACD,QAAId,SAAS,GAAGhC,SAAS,CAACyC,EAA1B,EAA8B;AAC5BN,MAAAA,UAAU,CAACE,IAAX,CAAgBtC,MAAM,CAACgD,kBAAvB;AACD;;AACD,QAAIf,SAAS,GAAGhC,SAAS,CAAC2C,IAA1B,EAAgC;AAC9BR,MAAAA,UAAU,CAACE,IAAX,CAAgBtC,MAAM,CAACgD,kBAAvB;AACD;;AACDZ,IAAAA,UAAU,GAAG,CAAC,GAAG,IAAIa,GAAJ,CAAQb,UAAR,CAAJ,CAAb;AAEA,QAAIA,UAAU,CAACc,MAAX,KAAsB,CAA1B,EAA6B,OAAOlD,MAAM,CAACmD,cAAd;AAC7B,QAAIf,UAAU,CAACc,MAAX,KAAsB,CAA1B,EAA6B,OAAOd,UAAU,CAAC,CAAD,CAAjB;AAC7B,WAAOpC,MAAM,CAACoD,aAAd;AACD;;AAEDC,EAAAA,wBAAwB,OAWtBC,UAXsB,SAatB;AAAA,QAZA;AACEC,MAAAA,WADF;AAEEC,MAAAA,WAFF;AAGExB,MAAAA,gBAHF;AAIEyB,MAAAA,OAJF;AAKEC,MAAAA,SALF;AAMEC,MAAAA,SANF;AAOEC,MAAAA,SAPF;AAQEC,MAAAA;AARF,KAYA;;AAAA,QADA;AAAEL,MAAAA,WAAW,EAAEM,aAAf;AAA8BC,MAAAA,MAAM,EAAEC,EAAtC;AAA0CC,MAAAA,MAAM,EAAEC;AAAlD,KACA;AAAA,QADyDC,KACzD;;AACA,QAAMC,iBAAiB,GAAGN,aAAa,KAAK9B,gBAA5C;;AACA,QAAI,CAACoC,iBAAD,IAAsB,KAAKpD,gBAA/B,EAAiD;AAC/C,aAAO;AAAEqD,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AACD,WAAO;AAAEC,MAAAA,OAAO,EAAEF;AAAX,KAAP;AACD;;AAEDG,EAAAA,mBAAmB,QAAgD;AAAA,QAA/C;AAAEvC,MAAAA,gBAAgB,GAAG,CAArB;AAAwBC,MAAAA;AAAxB,KAA+C;AAAA,QAATkC,KAAS;;AACjE,QAAI/D,KAAK,CAAC6B,SAAD,CAAL,IAAoB,OAAOA,SAAP,KAAqB,QAA7C,EAAuD;AACrD,YAAM,IAAI/B,gBAAJ,CAAqB,WAArB,EAAkC+B,SAAlC,EAA6C,QAA7C,CAAN;AACD;;AACD,WAAO,MAAMsC,mBAAN;AACLvC,MAAAA,gBADK;AAELC,MAAAA;AAFK,OAGFkC,KAHE,EAAP;AAKD;;AA9HsD;;AAiIzD,eAAe9D,mBAAf","sourcesContent":["import Hammer from '@egjs/hammerjs';\n\nimport { Direction } from './constants';\nimport { GesturePropError } from './Errors';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isnan } from './utils';\n\nclass FlingGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'swipe';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Swipe;\n  }\n\n  onGestureActivated(event) {\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_MOVE,\n      isFinal: false,\n      isFirst: true,\n    });\n    this.isGestureRunning = false;\n    this.hasGestureFailed = false;\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_END,\n      isFinal: true,\n    });\n  }\n\n  onRawEvent(ev) {\n    super.onRawEvent(ev);\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      setTimeout(() => {\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer.get(this.name);\n      if (gesture.options.enable(gesture, ev)) {\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      pointers: this.config.numberOfPointers,\n      direction: this.getDirection(),\n    };\n  }\n\n  getTargetDirections(direction) {\n    const directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_RIGHT);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_LEFT);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_UP);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_DOWN);\n    }\n    // const hammerDirection = directions.reduce((a, b) => a | b, 0);\n    return directions;\n  }\n\n  getDirection() {\n    const { direction } = this.getConfig();\n\n    let directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    directions = [...new Set(directions)];\n\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\n    if (directions.length === 1) return directions[0];\n    return Hammer.DIRECTION_ALL;\n  }\n\n  isGestureEnabledForEvent(\n    {\n      minPointers,\n      maxPointers,\n      numberOfPointers,\n      maxDist,\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside,\n    },\n    recognizer,\n    { maxPointers: pointerLength, deltaX: dx, deltaY: dy, ...props }\n  ) {\n    const validPointerCount = pointerLength === numberOfPointers;\n    if (!validPointerCount && this.isGestureRunning) {\n      return { failed: true };\n    }\n    return { success: validPointerCount };\n  }\n\n  updateGestureConfig({ numberOfPointers = 1, direction, ...props }) {\n    if (isnan(direction) || typeof direction !== 'number') {\n      throw new GesturePropError('direction', direction, 'number');\n    }\n    return super.updateGestureConfig({\n      numberOfPointers,\n      direction,\n      ...props,\n    });\n  }\n}\n\nexport default FlingGestureHandler;\n"]},"metadata":{},"sourceType":"module"}