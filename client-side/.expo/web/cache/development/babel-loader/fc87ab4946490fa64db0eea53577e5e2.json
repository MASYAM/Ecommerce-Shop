{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport GestureHandler from \"./GestureHandler\";\nimport { TEST_MAX_IF_NOT_NAN } from \"./utils\";\n\nclass DiscreteGestureHandler extends GestureHandler {\n  get isDiscrete() {\n    return true;\n  }\n\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  shouldFailUnderCustomCriteria(_ref, _ref2) {\n    var {\n      x,\n      y,\n      deltaX,\n      deltaY\n    } = _ref;\n    var {\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside\n    } = _ref2;\n\n    if (shouldCancelWhenOutside) {\n      if (!this.isPointInView({\n        x,\n        y\n      })) {\n        return true;\n      }\n    }\n\n    return TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq);\n  }\n\n  transformNativeEvent(_ref3) {\n    var {\n      x,\n      y\n    } = _ref3;\n    return {\n      absoluteX: x,\n      absoluteY: y,\n      x,\n      y\n    };\n  }\n\n  isGestureEnabledForEvent(_ref4, recognizer, _ref5) {\n    var {\n      minPointers,\n      maxPointers,\n      maxDist,\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside\n    } = _ref4;\n\n    var {\n      maxPointers: pointerLength,\n      center,\n      deltaX,\n      deltaY\n    } = _ref5,\n        props = _objectWithoutProperties(_ref5, [\"maxPointers\", \"center\", \"deltaX\", \"deltaY\"]);\n\n    var validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;\n\n    if (this.shouldFailUnderCustomCriteria(_objectSpread({}, center, {\n      deltaX,\n      deltaY\n    }), {\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside\n    }) || !validPointerCount && this.isGestureRunning) {\n      return {\n        failed: true\n      };\n    }\n\n    return {\n      success: validPointerCount\n    };\n  }\n\n}\n\nexport default DiscreteGestureHandler;","map":{"version":3,"sources":["/Users/m.asyam/Desktop/MY-PROJECTS/react-project/client-pack/node_modules/react-native-gesture-handler/web/DiscreteGestureHandler.js"],"names":["GestureHandler","TEST_MAX_IF_NOT_NAN","DiscreteGestureHandler","isDiscrete","shouldEnableGestureOnSetup","shouldFailUnderCustomCriteria","x","y","deltaX","deltaY","maxDeltaX","maxDeltaY","maxDistSq","shouldCancelWhenOutside","isPointInView","Math","abs","transformNativeEvent","absoluteX","absoluteY","isGestureEnabledForEvent","recognizer","minPointers","maxPointers","maxDist","pointerLength","center","props","validPointerCount","isGestureRunning","failed","success"],"mappings":";;;;;;;;;;AAAA,OAAOA,cAAP;AACA,SAASC,mBAAT;;AAEA,MAAMC,sBAAN,SAAqCF,cAArC,CAAoD;AAClD,MAAIG,UAAJ,GAAiB;AACf,WAAO,IAAP;AACD;;AAED,MAAIC,0BAAJ,GAAiC;AAC/B,WAAO,IAAP;AACD;;AAEDC,EAAAA,6BAA6B,cAG3B;AAAA,QAFA;AAAEC,MAAAA,CAAF;AAAKC,MAAAA,CAAL;AAAQC,MAAAA,MAAR;AAAgBC,MAAAA;AAAhB,KAEA;AAAA,QADA;AAAEC,MAAAA,SAAF;AAAaC,MAAAA,SAAb;AAAwBC,MAAAA,SAAxB;AAAmCC,MAAAA;AAAnC,KACA;;AACA,QAAIA,uBAAJ,EAA6B;AAC3B,UAAI,CAAC,KAAKC,aAAL,CAAmB;AAAER,QAAAA,CAAF;AAAKC,QAAAA;AAAL,OAAnB,CAAL,EAAmC;AACjC,eAAO,IAAP;AACD;AACF;;AACD,WACEN,mBAAmB,CAACc,IAAI,CAACC,GAAL,CAASR,MAAT,CAAD,EAAmBE,SAAnB,CAAnB,IACAT,mBAAmB,CAACc,IAAI,CAACC,GAAL,CAASP,MAAT,CAAD,EAAmBE,SAAnB,CADnB,IAEAV,mBAAmB,CAACc,IAAI,CAACC,GAAL,CAASP,MAAM,GAAGA,MAAT,GAAkBD,MAAM,GAAGA,MAApC,CAAD,EAA8CI,SAA9C,CAHrB;AAKD;;AAEDK,EAAAA,oBAAoB,QAAW;AAAA,QAAV;AAAEX,MAAAA,CAAF;AAAKC,MAAAA;AAAL,KAAU;AAC7B,WAAO;AACLW,MAAAA,SAAS,EAAEZ,CADN;AAELa,MAAAA,SAAS,EAAEZ,CAFN;AAGLD,MAAAA,CAHK;AAILC,MAAAA;AAJK,KAAP;AAMD;;AAEDa,EAAAA,wBAAwB,QAEtBC,UAFsB,SAItB;AAAA,QAHA;AAAEC,MAAAA,WAAF;AAAeC,MAAAA,WAAf;AAA4BC,MAAAA,OAA5B;AAAqCd,MAAAA,SAArC;AAAgDC,MAAAA,SAAhD;AAA2DC,MAAAA,SAA3D;AAAsEC,MAAAA;AAAtE,KAGA;;AAAA,QADA;AAAEU,MAAAA,WAAW,EAAEE,aAAf;AAA8BC,MAAAA,MAA9B;AAAsClB,MAAAA,MAAtC;AAA8CC,MAAAA;AAA9C,KACA;AAAA,QADyDkB,KACzD;;AACA,QAAMC,iBAAiB,GAAGH,aAAa,IAAIH,WAAjB,IAAgCG,aAAa,IAAIF,WAA3E;;AAEA,QACE,KAAKlB,6BAAL,mBACOqB,MADP;AACelB,MAAAA,MADf;AACuBC,MAAAA;AADvB,QAEE;AACEC,MAAAA,SADF;AAEEC,MAAAA,SAFF;AAGEC,MAAAA,SAHF;AAIEC,MAAAA;AAJF,KAFF,KAWC,CAACe,iBAAD,IAAsB,KAAKC,gBAZ9B,EAaE;AACA,aAAO;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AAED,WAAO;AAAEC,MAAAA,OAAO,EAAEH;AAAX,KAAP;AACD;;AA3DiD;;AA8DpD,eAAe1B,sBAAf","sourcesContent":["import GestureHandler from './GestureHandler';\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\n\nclass DiscreteGestureHandler extends GestureHandler {\n  get isDiscrete() {\n    return true;\n  }\n\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  shouldFailUnderCustomCriteria(\n    { x, y, deltaX, deltaY },\n    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }\n  ) {\n    if (shouldCancelWhenOutside) {\n      if (!this.isPointInView({ x, y })) {\n        return true;\n      }\n    }\n    return (\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq)\n    );\n  }\n\n  transformNativeEvent({ x, y }) {\n    return {\n      absoluteX: x,\n      absoluteY: y,\n      x,\n      y,\n    };\n  }\n\n  isGestureEnabledForEvent(\n    { minPointers, maxPointers, maxDist, maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside },\n    recognizer,\n    { maxPointers: pointerLength, center, deltaX, deltaY, ...props }\n  ) {\n    const validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;\n\n    if (\n      this.shouldFailUnderCustomCriteria(\n        { ...center, deltaX, deltaY },\n        {\n          maxDeltaX,\n          maxDeltaY,\n          maxDistSq,\n          shouldCancelWhenOutside,\n        }\n      ) ||\n      // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\n      // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\n      (!validPointerCount && this.isGestureRunning)\n    ) {\n      return { failed: true };\n    }\n\n    return { success: validPointerCount };\n  }\n}\n\nexport default DiscreteGestureHandler;\n"]},"metadata":{},"sourceType":"module"}