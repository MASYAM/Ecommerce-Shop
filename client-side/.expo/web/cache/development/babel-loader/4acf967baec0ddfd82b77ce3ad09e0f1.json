{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport React from 'react';\nimport Linking from \"react-native-web/dist/exports/Linking\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport BackHandler from \"react-native-web/dist/exports/BackHandler\";\nimport { NavigationActions, ThemeProvider, pathUtils, getNavigation, NavigationProvider } from '@react-navigation/core';\nimport invariant from \"./utils/invariant\";\nimport docsUrl from \"./utils/docsUrl\";\nvar {\n  urlToPathAndParams\n} = pathUtils;\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (props.persistenceKey) {\n    console.warn('You passed persistenceKey prop to a navigator. ' + 'The persistenceKey prop was replaced by a more flexible persistence mechanism, ' + 'please see the navigation state persistence docs for more information. ' + 'Passing the persistenceKey prop is a no-op.');\n  }\n\n  if (isStateful(props)) {\n    return;\n  }\n\n  var {\n    navigation,\n    screenProps,\n    persistNavigationState,\n    loadNavigationState,\n    theme\n  } = props,\n      containerProps = _objectWithoutProperties(props, [\"navigation\", \"screenProps\", \"persistNavigationState\", \"loadNavigationState\", \"theme\"]);\n\n  var keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error('This navigator has both navigation and container props, so it is ' + \"unclear if it should own its own state. Remove props: \\\"\".concat(keys.join(', '), \"\\\" \") + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n  }\n\n  invariant(persistNavigationState === undefined && loadNavigationState === undefined || typeof persistNavigationState === 'function' && typeof loadNavigationState === 'function', 'both persistNavigationState and loadNavigationState must either be undefined, or be functions');\n}\n\nvar _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\nvar _reactNavigationIsHydratingState = false;\nexport default function createNavigationContainer(Component) {\n  class NavigationContainer extends React.Component {\n    static getDerivedStateFromProps(nextProps) {\n      validateProps(nextProps);\n      return null;\n    }\n\n    constructor(props) {\n      var _this;\n\n      super(props);\n      _this = this;\n\n      _defineProperty(this, \"subs\", null);\n\n      _defineProperty(this, \"_actionEventSubscribers\", new Set());\n\n      _defineProperty(this, \"_handleOpenURL\", (_ref) => {\n        var {\n          url\n        } = _ref;\n        var {\n          enableURLHandling,\n          uriPrefix\n        } = this.props;\n\n        if (enableURLHandling === false) {\n          return;\n        }\n\n        var parsedUrl = urlToPathAndParams(url, uriPrefix);\n\n        if (parsedUrl) {\n          var {\n            path,\n            params\n          } = parsedUrl;\n          var action = Component.router.getActionForPathAndParams(path, params);\n\n          if (action) {\n            this.dispatch(action);\n          }\n        }\n      });\n\n      _defineProperty(this, \"_persistNavigationState\", function () {\n        var _ref2 = _asyncToGenerator(function* (nav) {\n          var {\n            persistNavigationState\n          } = _this.props;\n\n          if (persistNavigationState) {\n            try {\n              yield persistNavigationState(nav);\n            } catch (err) {\n              console.warn('Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.');\n            }\n          }\n        });\n\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n\n      _defineProperty(this, \"dispatch\", action => {\n        if (this.props.navigation) {\n          return this.props.navigation.dispatch(action);\n        }\n\n        this._navState = this._navState || this.state.nav;\n        var lastNavState = this._navState;\n        invariant(lastNavState, 'should be set in constructor if stateful');\n        var reducedState = Component.router.getStateForAction(action, lastNavState);\n        var navState = reducedState === null ? lastNavState : reducedState;\n\n        var dispatchActionEvents = () => {\n          this._actionEventSubscribers.forEach(subscriber => subscriber({\n            type: 'action',\n            action,\n            state: navState,\n            lastState: lastNavState\n          }));\n        };\n\n        if (reducedState === null) {\n          dispatchActionEvents();\n          return true;\n        }\n\n        if (navState !== lastNavState) {\n          this._navState = navState;\n          this.setState({\n            nav: navState\n          }, () => {\n            this._onNavigationStateChange(lastNavState, navState, action);\n\n            dispatchActionEvents();\n\n            this._persistNavigationState(navState);\n          });\n          return true;\n        }\n\n        dispatchActionEvents();\n        return false;\n      });\n\n      _defineProperty(this, \"_getScreenProps\", () => this.props.screenProps);\n\n      _defineProperty(this, \"_getTheme\", () => {\n        if (this.props.theme === 'light' || this.props.theme === 'dark') {\n          return this.props.theme;\n        } else if (this.props.theme === 'no-preference') {\n          return 'light';\n        } else {\n          console.warn(\"Invalid theme provided: \".concat(this.props.theme, \". Only 'light' and 'dark' are supported. Falling back to 'light'\"));\n          return 'light';\n        }\n      });\n\n      validateProps(props);\n      this._initialAction = NavigationActions.init();\n\n      if (this._isStateful() && BackHandler && typeof BackHandler.addEventListener === 'function') {\n        this.subs = BackHandler.addEventListener('hardwareBackPress', () => {\n          if (!this._isMounted) {\n            this.subs && this.subs.remove();\n          } else {\n            return this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n\n      this.state = {\n        nav: this._isStateful() && !props.loadNavigationState ? Component.router.getStateForAction(this._initialAction) : null\n      };\n    }\n\n    _renderLoading() {\n      return this.props.renderLoadingExperimental ? this.props.renderLoadingExperimental() : null;\n    }\n\n    _isStateful() {\n      return isStateful(this.props);\n    }\n\n    _onNavigationStateChange(prevNav, nav, action) {\n      if (typeof this.props.onNavigationStateChange === 'undefined' && this._isStateful() && !!process.env.REACT_NAV_LOGGING) {\n        if (console.group) {\n          console.group('Navigation Dispatch: ');\n          console.log('Action: ', action);\n          console.log('New State: ', nav);\n          console.log('Last State: ', prevNav);\n          console.groupEnd();\n        } else {\n          console.log('Navigation Dispatch: ', {\n            action,\n            newState: nav,\n            lastState: prevNav\n          });\n        }\n\n        return;\n      }\n\n      if (typeof this.props.onNavigationStateChange === 'function') {\n        this.props.onNavigationStateChange(prevNav, nav, action);\n      }\n    }\n\n    componentDidUpdate() {\n      if (this._navState === this.state.nav) {\n        this._navState = null;\n      }\n    }\n\n    componentDidMount() {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        _this2._isMounted = true;\n\n        if (!_this2._isStateful()) {\n          return;\n        }\n\n        if (process.env.NODE_ENV !== 'production' && !_this2.props.detached) {\n          if (_statefulContainerCount > 0) {\n            if (Platform.OS === 'ios') {\n              console.warn(\"You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: \".concat(docsUrl('common-mistakes.html#explicitly-rendering-more-than-one-navigator')));\n            }\n          }\n        }\n\n        _statefulContainerCount++;\n        Linking.addEventListener('url', _this2._handleOpenURL);\n        var parsedUrl = null;\n        var userProvidedStartupState = null;\n\n        if (_this2.props.enableURLHandling !== false) {\n          ({\n            parsedUrl,\n            userProvidedStartupState\n          } = yield _this2.getStartupParams());\n        }\n\n        var action = _this2._initialAction;\n        var startupState = _this2.state.nav;\n\n        if (!startupState && !userProvidedStartupState) {\n          !!process.env.REACT_NAV_LOGGING && console.log('Init new Navigation State');\n          startupState = Component.router.getStateForAction(action);\n        }\n\n        if (userProvidedStartupState) {\n          startupState = userProvidedStartupState;\n          _reactNavigationIsHydratingState = true;\n        }\n\n        if (parsedUrl) {\n          var {\n            path,\n            params\n          } = parsedUrl;\n          var urlAction = Component.router.getActionForPathAndParams(path, params);\n\n          if (urlAction) {\n            !!process.env.REACT_NAV_LOGGING && console.log('Applying Navigation Action for Initial URL:', parsedUrl);\n            action = urlAction;\n            startupState = Component.router.getStateForAction(urlAction, startupState);\n          }\n        }\n\n        var dispatchActions = () => _this2._actionEventSubscribers.forEach(subscriber => subscriber({\n          type: 'action',\n          action,\n          state: _this2.state.nav,\n          lastState: null\n        }));\n\n        if (startupState === _this2.state.nav) {\n          dispatchActions();\n          return;\n        }\n\n        _this2.setState({\n          nav: startupState\n        }, () => {\n          _reactNavigationIsHydratingState = false;\n          dispatchActions();\n        });\n      })();\n    }\n\n    getStartupParams() {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        var {\n          uriPrefix,\n          loadNavigationState\n        } = _this3.props;\n        var url, loadedNavState;\n\n        try {\n          [url, loadedNavState] = yield Promise.all([Linking.getInitialURL(), loadNavigationState && loadNavigationState()]);\n        } catch (err) {}\n\n        return {\n          parsedUrl: url && urlToPathAndParams(url, uriPrefix),\n          userProvidedStartupState: loadedNavState\n        };\n      })();\n    }\n\n    componentDidCatch(e) {\n      if (_reactNavigationIsHydratingState) {\n        _reactNavigationIsHydratingState = false;\n        console.warn('Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...');\n        this.dispatch(NavigationActions.init());\n      } else {\n        throw e;\n      }\n    }\n\n    componentWillUnmount() {\n      this._isMounted = false;\n      Linking.removeEventListener('url', this._handleOpenURL);\n      this.subs && this.subs.remove();\n\n      if (this._isStateful()) {\n        _statefulContainerCount--;\n      }\n    }\n\n    render() {\n      var navigation = this.props.navigation;\n\n      if (this._isStateful()) {\n        var navState = this.state.nav;\n\n        if (!navState) {\n          return this._renderLoading();\n        }\n\n        if (!this._navigation || this._navigation.state !== navState) {\n          this._navigation = getNavigation(Component.router, navState, this.dispatch, this._actionEventSubscribers, this._getScreenProps, () => this._navigation);\n        }\n\n        navigation = this._navigation;\n      }\n\n      invariant(navigation, 'failed to get navigation');\n      return React.createElement(ThemeProvider, {\n        value: this._getTheme()\n      }, React.createElement(NavigationProvider, {\n        value: navigation\n      }, React.createElement(Component, _extends({}, this.props, {\n        navigation: navigation\n      }))));\n    }\n\n  }\n\n  _defineProperty(NavigationContainer, \"router\", Component.router);\n\n  _defineProperty(NavigationContainer, \"navigationOptions\", null);\n\n  _defineProperty(NavigationContainer, \"defaultProps\", {\n    theme: 'light'\n  });\n\n  return NavigationContainer;\n}","map":{"version":3,"sources":["createAppContainer.js"],"names":["urlToPathAndParams","props","console","isStateful","theme","containerProps","keys","Object","invariant","persistNavigationState","loadNavigationState","_statefulContainerCount","_reactNavigationIsHydratingState","React","Component","validateProps","constructor","NavigationActions","BackHandler","nav","_renderLoading","_isStateful","url","uriPrefix","enableURLHandling","parsedUrl","params","action","_onNavigationStateChange","process","newState","lastState","prevNav","componentDidUpdate","Platform","docsUrl","Linking","userProvidedStartupState","startupState","urlAction","dispatchActions","subscriber","type","state","Promise","loadedNavState","componentDidCatch","componentWillUnmount","lastNavState","reducedState","navState","dispatchActionEvents","render","navigation","getNavigation"],"mappings":"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","sourcesContent":["/* eslint-disable react/sort-comp */\n\nimport React from 'react';\nimport { Linking, Platform, BackHandler } from 'react-native';\nimport {\n  NavigationActions,\n  ThemeProvider,\n  pathUtils,\n  getNavigation,\n  NavigationProvider,\n} from '@react-navigation/core';\nimport invariant from './utils/invariant';\nimport docsUrl from './utils/docsUrl';\n\nconst { urlToPathAndParams } = pathUtils;\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (props.persistenceKey) {\n    console.warn(\n      'You passed persistenceKey prop to a navigator. ' +\n        'The persistenceKey prop was replaced by a more flexible persistence mechanism, ' +\n        'please see the navigation state persistence docs for more information. ' +\n        'Passing the persistenceKey prop is a no-op.'\n    );\n  }\n  if (isStateful(props)) {\n    return;\n  }\n  /* eslint-disable no-unused-vars */\n  const {\n    navigation,\n    screenProps,\n    persistNavigationState,\n    loadNavigationState,\n    theme,\n    ...containerProps\n  } = props;\n  /* eslint-enable no-unused-vars */\n\n  const keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error(\n      'This navigator has both navigation and container props, so it is ' +\n        `unclear if it should own its own state. Remove props: \"${keys.join(\n          ', '\n        )}\" ` +\n        'if the navigator should get its state from the navigation prop. If the ' +\n        'navigator should maintain its own state, do not pass a navigation prop.'\n    );\n  }\n  invariant(\n    (persistNavigationState === undefined &&\n      loadNavigationState === undefined) ||\n      (typeof persistNavigationState === 'function' &&\n        typeof loadNavigationState === 'function'),\n    'both persistNavigationState and loadNavigationState must either be undefined, or be functions'\n  );\n}\n\n// Track the number of stateful container instances. Warn if >0 and not using the\n// detached prop to explicitly acknowledge the behavior. We should deprecated implicit\n// stateful navigation containers in a future release and require a provider style pattern\n// instead in order to eliminate confusion entirely.\nlet _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\n\n// We keep a global flag to catch errors during the state persistence hydrating scenario.\n// The innermost navigator who catches the error will dispatch a new init action.\nlet _reactNavigationIsHydratingState = false;\n// Unfortunate to use global state here, but it seems necessesary for the time\n// being. There seems to be some problems with cascading componentDidCatch\n// handlers. Ideally the inner non-stateful navigator catches the error and\n// re-throws it, to be caught by the top-level stateful navigator.\n\n/**\n * Create an HOC that injects the navigation and manages the navigation state\n * in case it's not passed from above.\n * This allows to use e.g. the StackNavigator and TabNavigator as root-level\n * components.\n */\nexport default function createNavigationContainer(Component) {\n  class NavigationContainer extends React.Component {\n    subs = null;\n\n    static router = Component.router;\n    static navigationOptions = null;\n\n    static defaultProps = {\n      theme: 'light',\n    };\n\n    static getDerivedStateFromProps(nextProps) {\n      validateProps(nextProps);\n      return null;\n    }\n\n    _actionEventSubscribers = new Set();\n\n    constructor(props) {\n      super(props);\n\n      validateProps(props);\n\n      this._initialAction = NavigationActions.init();\n\n      if (\n        this._isStateful() &&\n        BackHandler &&\n        typeof BackHandler.addEventListener === 'function'\n      ) {\n        this.subs = BackHandler.addEventListener('hardwareBackPress', () => {\n          if (!this._isMounted) {\n            this.subs && this.subs.remove();\n          } else {\n            // dispatch returns true if the action results in a state change,\n            // and false otherwise. This maps well to what BackHandler expects\n            // from a callback -- true if handled, false if not handled\n            return this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n\n      this.state = {\n        nav:\n          this._isStateful() && !props.loadNavigationState\n            ? Component.router.getStateForAction(this._initialAction)\n            : null,\n      };\n    }\n\n    _renderLoading() {\n      return this.props.renderLoadingExperimental\n        ? this.props.renderLoadingExperimental()\n        : null;\n    }\n\n    _isStateful() {\n      return isStateful(this.props);\n    }\n\n    _handleOpenURL = ({ url }) => {\n      const { enableURLHandling, uriPrefix } = this.props;\n      if (enableURLHandling === false) {\n        return;\n      }\n      const parsedUrl = urlToPathAndParams(url, uriPrefix);\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const action = Component.router.getActionForPathAndParams(path, params);\n        if (action) {\n          this.dispatch(action);\n        }\n      }\n    };\n\n    _onNavigationStateChange(prevNav, nav, action) {\n      if (\n        typeof this.props.onNavigationStateChange === 'undefined' &&\n        this._isStateful() &&\n        !!process.env.REACT_NAV_LOGGING\n      ) {\n        if (console.group) {\n          console.group('Navigation Dispatch: ');\n          console.log('Action: ', action);\n          console.log('New State: ', nav);\n          console.log('Last State: ', prevNav);\n          console.groupEnd();\n        } else {\n          console.log('Navigation Dispatch: ', {\n            action,\n            newState: nav,\n            lastState: prevNav,\n          });\n        }\n        return;\n      }\n\n      if (typeof this.props.onNavigationStateChange === 'function') {\n        this.props.onNavigationStateChange(prevNav, nav, action);\n      }\n    }\n\n    componentDidUpdate() {\n      // Clear cached _navState every tick\n      if (this._navState === this.state.nav) {\n        this._navState = null;\n      }\n    }\n\n    async componentDidMount() {\n      this._isMounted = true;\n      if (!this._isStateful()) {\n        return;\n      }\n\n      if (process.env.NODE_ENV !== 'production' && !this.props.detached) {\n        if (_statefulContainerCount > 0) {\n          // Temporarily only show this on iOS due to this issue:\n          // https://github.com/react-navigation/react-navigation/issues/4196#issuecomment-390827829\n          if (Platform.OS === 'ios') {\n            console.warn(\n              `You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: ${docsUrl(\n                'common-mistakes.html#explicitly-rendering-more-than-one-navigator'\n              )}`\n            );\n          }\n        }\n      }\n      _statefulContainerCount++;\n      Linking.addEventListener('url', this._handleOpenURL);\n\n      // Pull out anything that can impact state\n      let parsedUrl = null;\n      let userProvidedStartupState = null;\n      if (this.props.enableURLHandling !== false) {\n        ({\n          parsedUrl,\n          userProvidedStartupState,\n        } = await this.getStartupParams());\n      }\n\n      // Initialize state. This must be done *after* any async code\n      // so we don't end up with a different value for this.state.nav\n      // due to changes while async function was resolving\n      let action = this._initialAction;\n      // eslint-disable-next-line react/no-access-state-in-setstate\n      let startupState = this.state.nav;\n      if (!startupState && !userProvidedStartupState) {\n        !!process.env.REACT_NAV_LOGGING &&\n          console.log('Init new Navigation State');\n        startupState = Component.router.getStateForAction(action);\n      }\n\n      // Pull user-provided persisted state\n      if (userProvidedStartupState) {\n        startupState = userProvidedStartupState;\n        _reactNavigationIsHydratingState = true;\n      }\n\n      // Pull state out of URL\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const urlAction = Component.router.getActionForPathAndParams(\n          path,\n          params\n        );\n        if (urlAction) {\n          !!process.env.REACT_NAV_LOGGING &&\n            console.log(\n              'Applying Navigation Action for Initial URL:',\n              parsedUrl\n            );\n          action = urlAction;\n          startupState = Component.router.getStateForAction(\n            urlAction,\n            startupState\n          );\n        }\n      }\n\n      const dispatchActions = () =>\n        this._actionEventSubscribers.forEach((subscriber) =>\n          subscriber({\n            type: 'action',\n            action,\n            state: this.state.nav,\n            lastState: null,\n          })\n        );\n\n      if (startupState === this.state.nav) {\n        dispatchActions();\n        return;\n      }\n\n      // eslint-disable-next-line react/no-did-mount-set-state\n      this.setState({ nav: startupState }, () => {\n        _reactNavigationIsHydratingState = false;\n        dispatchActions();\n      });\n    }\n\n    async getStartupParams() {\n      const { uriPrefix, loadNavigationState } = this.props;\n      let url, loadedNavState;\n      try {\n        [url, loadedNavState] = await Promise.all([\n          Linking.getInitialURL(),\n          loadNavigationState && loadNavigationState(),\n        ]);\n      } catch (err) {\n        // ignore\n      }\n      return {\n        parsedUrl: url && urlToPathAndParams(url, uriPrefix),\n        userProvidedStartupState: loadedNavState,\n      };\n    }\n\n    componentDidCatch(e) {\n      if (_reactNavigationIsHydratingState) {\n        _reactNavigationIsHydratingState = false;\n        console.warn(\n          'Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...'\n        );\n        this.dispatch(NavigationActions.init());\n      } else {\n        throw e;\n      }\n    }\n\n    _persistNavigationState = async (nav) => {\n      const { persistNavigationState } = this.props;\n      if (persistNavigationState) {\n        try {\n          await persistNavigationState(nav);\n        } catch (err) {\n          console.warn(\n            'Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.'\n          );\n        }\n      }\n    };\n\n    componentWillUnmount() {\n      this._isMounted = false;\n      Linking.removeEventListener('url', this._handleOpenURL);\n      this.subs && this.subs.remove();\n\n      if (this._isStateful()) {\n        _statefulContainerCount--;\n      }\n    }\n\n    // Per-tick temporary storage for state.nav\n\n    dispatch = (action) => {\n      if (this.props.navigation) {\n        return this.props.navigation.dispatch(action);\n      }\n\n      // navState will have the most up-to-date value, because setState sometimes behaves asyncronously\n      this._navState = this._navState || this.state.nav;\n      const lastNavState = this._navState;\n      invariant(lastNavState, 'should be set in constructor if stateful');\n      const reducedState = Component.router.getStateForAction(\n        action,\n        lastNavState\n      );\n      const navState = reducedState === null ? lastNavState : reducedState;\n\n      const dispatchActionEvents = () => {\n        this._actionEventSubscribers.forEach((subscriber) =>\n          subscriber({\n            type: 'action',\n            action,\n            state: navState,\n            lastState: lastNavState,\n          })\n        );\n      };\n\n      if (reducedState === null) {\n        // The router will return null when action has been handled and the state hasn't changed.\n        // dispatch returns true when something has been handled.\n        dispatchActionEvents();\n        return true;\n      }\n\n      if (navState !== lastNavState) {\n        // Cache updates to state.nav during the tick to ensure that subsequent calls will not discard this change\n        this._navState = navState;\n        this.setState({ nav: navState }, () => {\n          this._onNavigationStateChange(lastNavState, navState, action);\n          dispatchActionEvents();\n          this._persistNavigationState(navState);\n        });\n        return true;\n      }\n\n      dispatchActionEvents();\n      return false;\n    };\n\n    _getScreenProps = () => this.props.screenProps;\n\n    _getTheme = () => {\n      if (this.props.theme === 'light' || this.props.theme === 'dark') {\n        return this.props.theme;\n      } else if (this.props.theme === 'no-preference') {\n        return 'light';\n      } else {\n        console.warn(\n          `Invalid theme provided: ${this.props.theme}. Only 'light' and 'dark' are supported. Falling back to 'light'`\n        );\n        return 'light';\n      }\n    };\n\n    render() {\n      let navigation = this.props.navigation;\n      if (this._isStateful()) {\n        const navState = this.state.nav;\n        if (!navState) {\n          return this._renderLoading();\n        }\n        if (!this._navigation || this._navigation.state !== navState) {\n          this._navigation = getNavigation(\n            Component.router,\n            navState,\n            this.dispatch,\n            this._actionEventSubscribers,\n            this._getScreenProps,\n            () => this._navigation\n          );\n        }\n        navigation = this._navigation;\n      }\n      invariant(navigation, 'failed to get navigation');\n\n      return (\n        <ThemeProvider value={this._getTheme()}>\n          <NavigationProvider value={navigation}>\n            <Component {...this.props} navigation={navigation} />\n          </NavigationProvider>\n        </ThemeProvider>\n      );\n    }\n  }\n\n  return NavigationContainer;\n}\n"]},"metadata":{},"sourceType":"module"}