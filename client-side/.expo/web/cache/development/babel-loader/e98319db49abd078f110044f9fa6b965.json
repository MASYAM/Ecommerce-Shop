{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { getAssetForSource, loadSingleFontAsync, fontFamilyNeedsScoping, getNativeFontName } from \"./FontLoader\";\nvar loaded = {};\nvar loadPromises = {};\nexport function processFontFamily(name) {\n  if (!name || !fontFamilyNeedsScoping(name)) {\n    return name;\n  }\n\n  if (!isLoaded(name)) {\n    if (__DEV__) {\n      if (isLoading(name)) {\n        console.error(\"You started loading the font \\\"\".concat(name, \"\\\", but used it before it finished loading.\\n\\n- You need to wait for Font.loadAsync to complete before using the font.\\n\\n- We recommend loading all fonts before rendering the app, and rendering only Expo.AppLoading while waiting for loading to complete.\"));\n      } else {\n        console.error(\"fontFamily \\\"\".concat(name, \"\\\" is not a system font and has not been loaded through Font.loadAsync.\\n\\n- If you intended to use a system font, make sure you typed the name correctly and that it is supported by your device operating system.\\n\\n- If this is a custom font, be sure to load it with Font.loadAsync.\"));\n      }\n    }\n\n    return 'System';\n  }\n\n  return \"ExpoFont-\".concat(getNativeFontName(name));\n}\nexport function isLoaded(name) {\n  return loaded.hasOwnProperty(name);\n}\nexport function isLoading(name) {\n  return loadPromises.hasOwnProperty(name);\n}\nexport function loadAsync(_x, _x2) {\n  return _loadAsync.apply(this, arguments);\n}\n\nfunction _loadAsync() {\n  _loadAsync = _asyncToGenerator(function* (nameOrMap, source) {\n    if (typeof nameOrMap === 'object') {\n      var fontMap = nameOrMap;\n      var names = Object.keys(fontMap);\n      yield Promise.all(names.map(name => loadAsync(name, fontMap[name])));\n      return;\n    }\n\n    var name = nameOrMap;\n\n    if (loaded[name]) {\n      return;\n    }\n\n    if (loadPromises[name]) {\n      return loadPromises[name];\n    }\n\n    if (!source) {\n      throw new Error(\"No source from which to load font \\\"\".concat(name, \"\\\"\"));\n    }\n\n    var asset = getAssetForSource(source);\n    loadPromises[name] = _asyncToGenerator(function* () {\n      try {\n        yield loadSingleFontAsync(name, asset);\n        loaded[name] = true;\n      } finally {\n        delete loadPromises[name];\n      }\n    })();\n    yield loadPromises[name];\n  });\n  return _loadAsync.apply(this, arguments);\n}\n\nif (module && module.exports) {\n  var wasImportWarningShown = false;\n  Object.defineProperty(exports, 'Font', {\n    get() {\n      if (!wasImportWarningShown) {\n        console.warn(\"The syntax \\\"import { Font } from 'expo-font'\\\" is deprecated. Use \\\"import * as Font from 'expo-font'\\\" or import named exports instead. Support for the old syntax will be removed in SDK 33.\");\n        wasImportWarningShown = true;\n      }\n\n      return {\n        processFontFamily,\n        isLoaded,\n        isLoading,\n        loadAsync\n      };\n    }\n\n  });\n}","map":{"version":3,"sources":["../src/Font.ts"],"names":[],"mappings":";;;;AAAA,SACE,iBADF,EAEE,mBAFF,EAGE,sBAHF,EAIE,iBAJF;AASA,IAAM,MAAM,GAAgC,EAA5C;AACA,IAAM,YAAY,GAAsC,EAAxD;AASA,OAAM,SAAU,iBAAV,CAA4B,IAA5B,EAA+C;AACnD,MAAI,CAAC,IAAD,IAAS,CAAC,sBAAsB,CAAC,IAAD,CAApC,EAA4C;AAC1C,WAAO,IAAP;AACD;;AAED,MAAI,CAAC,QAAQ,CAAC,IAAD,CAAb,EAAqB;AACnB,QAAI,OAAJ,EAAa;AACX,UAAI,SAAS,CAAC,IAAD,CAAb,EAAqB;AACnB,QAAA,OAAO,CAAC,KAAR,0CACmC,IADnC;AAKD,OAND,MAMO;AACL,QAAA,OAAO,CAAC,KAAR,wBACiB,IADjB;AAKD;AACF;;AAED,WAAO,QAAP;AACD;;AAED,4BAAmB,iBAAiB,CAAC,IAAD,CAApC;AACD;AAED,OAAM,SAAU,QAAV,CAAmB,IAAnB,EAA+B;AACnC,SAAO,MAAM,CAAC,cAAP,CAAsB,IAAtB,CAAP;AACD;AAED,OAAM,SAAU,SAAV,CAAoB,IAApB,EAAgC;AACpC,SAAO,YAAY,CAAC,cAAb,CAA4B,IAA5B,CAAP;AACD;AAED,gBAAsB,SAAtB;AAAA;AAAA;;;iCAAO,WACL,SADK,EAEL,MAFK,EAEc;AAEnB,QAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AACjC,UAAM,OAAO,GAAG,SAAhB;AACA,UAAM,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,OAAZ,CAAd;AACA,YAAM,OAAO,CAAC,GAAR,CAAY,KAAK,CAAC,GAAN,CAAU,IAAI,IAAI,SAAS,CAAC,IAAD,EAAO,OAAO,CAAC,IAAD,CAAd,CAA3B,CAAZ,CAAN;AACA;AACD;;AAED,QAAM,IAAI,GAAG,SAAb;;AAEA,QAAI,MAAM,CAAC,IAAD,CAAV,EAAkB;AAChB;AACD;;AAED,QAAI,YAAY,CAAC,IAAD,CAAhB,EAAwB;AACtB,aAAO,YAAY,CAAC,IAAD,CAAnB;AACD;;AAOD,QAAI,CAAC,MAAL,EAAa;AACX,YAAM,IAAI,KAAJ,+CAAgD,IAAhD,QAAN;AACD;;AACD,QAAM,KAAK,GAAG,iBAAiB,CAAC,MAAD,CAA/B;AACA,IAAA,YAAY,CAAC,IAAD,CAAZ,GAAqB,kBAAC,aAAW;AAC/B,UAAI;AACF,cAAM,mBAAmB,CAAC,IAAD,EAAO,KAAP,CAAzB;AACA,QAAA,MAAM,CAAC,IAAD,CAAN,GAAe,IAAf;AACD,OAHD,SAGU;AACR,eAAO,YAAY,CAAC,IAAD,CAAnB;AACD;AACF,KAPoB,GAArB;AASA,UAAM,YAAY,CAAC,IAAD,CAAlB;AACD,G;;;;AAMD,IAAI,MAAM,IAAI,MAAM,CAAC,OAArB,EAA8B;AAC5B,MAAI,qBAAqB,GAAG,KAA5B;AAEA,EAAA,MAAM,CAAC,cAAP,CAAsB,OAAtB,EAA+B,MAA/B,EAAuC;AACrC,IAAA,GAAG,GAAA;AACD,UAAI,CAAC,qBAAL,EAA4B;AAC1B,QAAA,OAAO,CAAC,IAAR;AAGA,QAAA,qBAAqB,GAAG,IAAxB;AACD;;AACD,aAAO;AACL,QAAA,iBADK;AAEL,QAAA,QAFK;AAGL,QAAA,SAHK;AAIL,QAAA;AAJK,OAAP;AAMD;;AAdoC,GAAvC;AAgBD","sourcesContent":["import {\n  getAssetForSource,\n  loadSingleFontAsync,\n  fontFamilyNeedsScoping,\n  getNativeFontName,\n} from './FontLoader';\n\nimport { FontSource, FontResource } from './Font.types';\n\nconst loaded: { [name: string]: boolean } = {};\nconst loadPromises: { [name: string]: Promise<void> } = {};\n\n/**\n * Used to transform font family names to the scoped name. This does not need to\n * be called in standalone or bare apps but it will return unscoped font family\n * names if it is called in those contexts.\n * note(brentvatne): at some point we may want to warn if this is called\n * outside of a managed app.\n */\nexport function processFontFamily(name: string | null): string | null {\n  if (!name || !fontFamilyNeedsScoping(name)) {\n    return name;\n  }\n\n  if (!isLoaded(name)) {\n    if (__DEV__) {\n      if (isLoading(name)) {\n        console.error(\n          `You started loading the font \"${name}\", but used it before it finished loading.\\n\n- You need to wait for Font.loadAsync to complete before using the font.\\n\n- We recommend loading all fonts before rendering the app, and rendering only Expo.AppLoading while waiting for loading to complete.`\n        );\n      } else {\n        console.error(\n          `fontFamily \"${name}\" is not a system font and has not been loaded through Font.loadAsync.\\n\n- If you intended to use a system font, make sure you typed the name correctly and that it is supported by your device operating system.\\n\n- If this is a custom font, be sure to load it with Font.loadAsync.`\n        );\n      }\n    }\n\n    return 'System';\n  }\n\n  return `ExpoFont-${getNativeFontName(name)}`;\n}\n\nexport function isLoaded(name: string): boolean {\n  return loaded.hasOwnProperty(name);\n}\n\nexport function isLoading(name: string): boolean {\n  return loadPromises.hasOwnProperty(name);\n}\n\nexport async function loadAsync(\n  nameOrMap: string | { [name: string]: FontSource },\n  source?: FontSource\n): Promise<void> {\n  if (typeof nameOrMap === 'object') {\n    const fontMap = nameOrMap;\n    const names = Object.keys(fontMap);\n    await Promise.all(names.map(name => loadAsync(name, fontMap[name])));\n    return;\n  }\n\n  const name = nameOrMap;\n\n  if (loaded[name]) {\n    return;\n  }\n\n  if (loadPromises[name]) {\n    return loadPromises[name];\n  }\n\n  // Important: we want all callers that concurrently try to load the same font to await the same\n  // promise. If we're here, we haven't created the promise yet. To ensure we create only one\n  // promise in the program, we need to create the promise synchronously without yielding the event\n  // loop from this point.\n\n  if (!source) {\n    throw new Error(`No source from which to load font \"${name}\"`);\n  }\n  const asset = getAssetForSource(source);\n  loadPromises[name] = (async () => {\n    try {\n      await loadSingleFontAsync(name, asset);\n      loaded[name] = true;\n    } finally {\n      delete loadPromises[name];\n    }\n  })();\n\n  await loadPromises[name];\n}\n\nexport { FontSource, FontResource };\n\ndeclare var module: any;\n\nif (module && module.exports) {\n  let wasImportWarningShown = false;\n  // @ts-ignore: Temporarily define an export named \"Font\" for legacy compatibility\n  Object.defineProperty(exports, 'Font', {\n    get() {\n      if (!wasImportWarningShown) {\n        console.warn(\n          `The syntax \"import { Font } from 'expo-font'\" is deprecated. Use \"import * as Font from 'expo-font'\" or import named exports instead. Support for the old syntax will be removed in SDK 33.`\n        );\n        wasImportWarningShown = true;\n      }\n      return {\n        processFontFamily,\n        isLoaded,\n        isLoading,\n        loadAsync,\n      };\n    },\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}