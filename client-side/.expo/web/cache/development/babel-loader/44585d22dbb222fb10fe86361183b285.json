{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport ExpoFontLoader from \"./ExpoFontLoader\";\nexport function fontFamilyNeedsScoping(name) {\n  return false;\n}\n\nfunction isAsset(asset) {\n  return typeof asset === 'object' && 'uri' in asset && 'name' in asset;\n}\n\nexport function getAssetForSource(source) {\n  if (isAsset(source)) {\n    return {\n      uri: source.uri || source.localUri\n    };\n  }\n\n  if (typeof source !== 'string') {\n    throw new Error(\"Unexpected type \".concat(typeof source, \" expected a URI string or Asset from expo-asset.\"));\n  }\n\n  return {\n    uri: source\n  };\n}\nexport function loadSingleFontAsync(_x, _x2) {\n  return _loadSingleFontAsync.apply(this, arguments);\n}\n\nfunction _loadSingleFontAsync() {\n  _loadSingleFontAsync = _asyncToGenerator(function* (name, input) {\n    var asset = input;\n\n    if (asset.downloadAsync) {\n      throw new Error('expo-font: loadSingleFontAsync expected an asset of type FontResource on web');\n    }\n\n    yield ExpoFontLoader.loadAsync(name, input);\n  });\n  return _loadSingleFontAsync.apply(this, arguments);\n}\n\nexport function getNativeFontName(name) {\n  return name;\n}","map":{"version":3,"sources":["../src/FontLoader.web.ts"],"names":[],"mappings":";;;;AACA,OAAO,cAAP;AAGA,OAAM,SAAU,sBAAV,CAAiC,IAAjC,EAA6C;AACjD,SAAO,KAAP;AACD;;AAED,SAAS,OAAT,CAAiB,KAAjB,EAA2B;AACzB,SAAO,OAAO,KAAP,KAAiB,QAAjB,IAA6B,SAAS,KAAtC,IAA+C,UAAU,KAAhE;AACD;;AAED,OAAM,SAAU,iBAAV,CAA4B,MAA5B,EAA8C;AAClD,MAAI,OAAO,CAAC,MAAD,CAAX,EAAqB;AACnB,WAAO;AACL,MAAA,GAAG,EAAE,MAAM,CAAC,GAAP,IAAc,MAAM,CAAC;AADrB,KAAP;AAGD;;AAED,MAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,UAAM,IAAI,KAAJ,2BACe,OAAO,MADtB,sDAAN;AAGD;;AAED,SAAO;AACL,IAAA,GAAG,EAAE;AADA,GAAP;AAGD;AAED,gBAAsB,mBAAtB;AAAA;AAAA;;;2CAAO,WACL,IADK,EAEL,KAFK,EAEsB;AAE3B,QAAM,KAAK,GAAG,KAAd;;AACA,QAAI,KAAK,CAAC,aAAV,EAAyB;AACvB,YAAM,IAAI,KAAJ,CAAU,8EAAV,CAAN;AACD;;AAED,UAAM,cAAc,CAAC,SAAf,CAAyB,IAAzB,EAA+B,KAA/B,CAAN;AACD,G;;;;AAED,OAAM,SAAU,iBAAV,CAA4B,IAA5B,EAAwC;AAC5C,SAAO,IAAP;AACD","sourcesContent":["import { Asset } from 'expo-asset';\nimport ExpoFontLoader from './ExpoFontLoader';\nimport { FontSource, FontResource } from './Font.types';\n\nexport function fontFamilyNeedsScoping(name: string): boolean {\n  return false;\n}\n\nfunction isAsset(asset: any): asset is Asset {\n  return typeof asset === 'object' && 'uri' in asset && 'name' in asset;\n}\n\nexport function getAssetForSource(source: FontSource): FontResource {\n  if (isAsset(source)) {\n    return {\n      uri: source.uri || source.localUri!,\n    };\n  }\n\n  if (typeof source !== 'string') {\n    throw new Error(\n      `Unexpected type ${typeof source} expected a URI string or Asset from expo-asset.`\n    );\n  }\n\n  return {\n    uri: source,\n  };\n}\n\nexport async function loadSingleFontAsync(\n  name: string,\n  input: Asset | FontResource\n): Promise<void> {\n  const asset = input as any;\n  if (asset.downloadAsync) {\n    throw new Error('expo-font: loadSingleFontAsync expected an asset of type FontResource on web');\n  }\n\n  await ExpoFontLoader.loadAsync(name, input);\n}\n\nexport function getNativeFontName(name: string): string {\n  return name;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}