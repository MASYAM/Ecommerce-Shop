{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport UUID from 'uuid-js';\nimport { guardPermission, getExponentPushTokenAsync, getDevicePushTokenAsync } from \"./ExponentNotificationsHelper.web\";\nimport \"./ExponentNotifications.fx.web\";\n\nfunction transformLocalNotification(notification, tag) {\n  var {\n    web = {}\n  } = notification,\n      abstractNotification = _objectWithoutProperties(notification, [\"web\"]);\n\n  tag = web.tag || tag;\n\n  var nativeNotification = _objectSpread(_objectSpread(_objectSpread({}, abstractNotification), {}, {\n    tag\n  }, web), {}, {\n    _isLocal: true\n  });\n\n  return [nativeNotification.title, nativeNotification];\n}\n\nfunction generateID() {\n  return UUID.create().toString();\n}\n\nfunction getRegistrationAsync() {\n  return _getRegistrationAsync.apply(this, arguments);\n}\n\nfunction _getRegistrationAsync() {\n  _getRegistrationAsync = _asyncToGenerator(function* () {\n    guardPermission();\n    var registration = yield navigator.serviceWorker.getRegistration();\n\n    if (!registration) {\n      throw new Error('Failed to get notification registration!');\n    }\n\n    return registration;\n  });\n  return _getRegistrationAsync.apply(this, arguments);\n}\n\nfunction getNotificationsAsync(_x) {\n  return _getNotificationsAsync.apply(this, arguments);\n}\n\nfunction _getNotificationsAsync() {\n  _getNotificationsAsync = _asyncToGenerator(function* (tag) {\n    var registration = yield getRegistrationAsync();\n    var notifications = yield registration.getNotifications(tag ? {\n      tag\n    } : undefined);\n    return notifications;\n  });\n  return _getNotificationsAsync.apply(this, arguments);\n}\n\nexport default {\n  presentLocalNotification(notification) {\n    return _asyncToGenerator(function* () {\n      var registration = yield getRegistrationAsync();\n      var tag = generateID();\n      registration.showNotification(...transformLocalNotification(notification, tag));\n      return tag;\n    })();\n  },\n\n  scheduleLocalNotification(notification) {\n    var _arguments = arguments,\n        _this = this;\n\n    return _asyncToGenerator(function* () {\n      var options = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};\n\n      if (options.intervalMs) {\n        var registration = yield getRegistrationAsync();\n        var tag = generateID();\n        setTimeout(() => {\n          registration.showNotification(...transformLocalNotification(notification, tag));\n        }, options.intervalMs);\n        return tag;\n      } else if (options.time) {\n        var intervalMs = options.time - Date.now();\n\n        if (intervalMs < 0) {\n          throw new Error('Expo.Notifications.scheduleLocalNotification(): options.time must be some time in the future.');\n        }\n\n        return _this.scheduleLocalNotification(notification, {\n          intervalMs\n        });\n      }\n\n      throw new Error(\"Expo.Notifications.scheduleLocalNotification() options \".concat(JSON.stringify(options, null, 2), \" are not supported yet.\"));\n    })();\n  },\n\n  dismissNotification(notificationId) {\n    return _asyncToGenerator(function* () {\n      var notifications = yield getNotificationsAsync(notificationId);\n\n      for (var notification of notifications) {\n        notification.close();\n      }\n    })();\n  },\n\n  dismissAllNotifications() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2.dismissNotification();\n    })();\n  },\n\n  cancelScheduledNotificationAsync(notificationId) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      _this3.dismissNotification(notificationId);\n    })();\n  },\n\n  cancelAllScheduledNotificationsAsync() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      _this4.dismissNotification();\n    })();\n  },\n\n  getExponentPushTokenAsync() {\n    return _asyncToGenerator(function* () {\n      return yield getExponentPushTokenAsync();\n    })();\n  },\n\n  getDevicePushTokenAsync() {\n    return _asyncToGenerator(function* () {\n      return yield getDevicePushTokenAsync();\n    })();\n  }\n\n};","map":{"version":3,"sources":["../../src/Notifications/ExponentNotifications.web.ts"],"names":[],"mappings":"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","sourcesContent":["import UUID from 'uuid-js';\n\nimport { LocalNotification, LocalNotificationId } from './Notifications.types';\nimport {\n  guardPermission,\n  getExponentPushTokenAsync,\n  getDevicePushTokenAsync,\n} from './ExponentNotificationsHelper.web';\n\n// Register `message`'s event listener (side-effect)\nimport './ExponentNotifications.fx.web';\n\nfunction transformLocalNotification(\n  notification: LocalNotification,\n  tag: string\n): [string, NotificationOptions] {\n  const { web = {}, ...abstractNotification } = notification;\n  tag = web.tag || tag;\n  const nativeNotification = {\n    ...abstractNotification,\n    tag,\n    ...web,\n    // Show that this notification is a local notification\n    _isLocal: true,\n  };\n  return [nativeNotification.title, nativeNotification];\n}\n\nfunction generateID(): string {\n  return UUID.create().toString();\n}\n\nasync function getRegistrationAsync(): Promise<ServiceWorkerRegistration> {\n  guardPermission();\n  const registration = await navigator.serviceWorker.getRegistration();\n  if (!registration) {\n    throw new Error('Failed to get notification registration!');\n  }\n  return registration;\n}\n\nasync function getNotificationsAsync(tag?: string): Promise<Notification[]> {\n  const registration = await getRegistrationAsync();\n  const notifications = await registration.getNotifications(tag ? { tag } : undefined);\n  return notifications;\n}\n\nexport default {\n  async presentLocalNotification(notification: LocalNotification): Promise<LocalNotificationId> {\n    const registration = await getRegistrationAsync();\n    const tag = generateID();\n    registration.showNotification(...transformLocalNotification(notification, tag));\n    return tag;\n  },\n  async scheduleLocalNotification(\n    notification: any,\n    options: {\n      time?: Date | number;\n      repeat?: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';\n      intervalMs?: number;\n    } = {}\n  ): Promise<string> {\n    if (options.intervalMs) {\n      const registration = await getRegistrationAsync();\n      const tag = generateID();\n      setTimeout(() => {\n        registration.showNotification(...transformLocalNotification(notification, tag));\n      }, options.intervalMs);\n      return tag;\n    } else if (options.time) {\n      const intervalMs = (options.time as number) - Date.now();\n      if (intervalMs < 0) {\n        throw new Error(\n          'Expo.Notifications.scheduleLocalNotification(): options.time must be some time in the future.'\n        );\n      }\n      return this.scheduleLocalNotification(notification, {\n        intervalMs,\n      });\n    }\n    throw new Error(\n      `Expo.Notifications.scheduleLocalNotification() options ${JSON.stringify(\n        options,\n        null,\n        2\n      )} are not supported yet.`\n    );\n  },\n\n  async dismissNotification(notificationId?: string): Promise<void> {\n    const notifications = await getNotificationsAsync(notificationId);\n    for (const notification of notifications) {\n      notification.close();\n    }\n  },\n  async dismissAllNotifications(): Promise<void> {\n    this.dismissNotification();\n  },\n  async cancelScheduledNotificationAsync(notificationId: string): Promise<void> {\n    this.dismissNotification(notificationId);\n  },\n  async cancelAllScheduledNotificationsAsync(): Promise<void> {\n    this.dismissNotification();\n  },\n\n  async getExponentPushTokenAsync(): Promise<string> {\n    return await getExponentPushTokenAsync();\n  },\n\n  async getDevicePushTokenAsync(): Promise<{ type: string; data: Object }> {\n    return await getDevicePushTokenAsync();\n  },\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}