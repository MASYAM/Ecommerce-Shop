{"ast":null,"code":"var _jsxFileName = \"/Users/m.asyam/Desktop/MY-PROJECTS/react-project/client-pack/node_modules/native-base-shoutem-theme/src/connectStyle.js\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport hoistStatics from 'hoist-non-react-statics';\nimport * as _ from 'lodash';\nimport normalizeStyle from \"./StyleNormalizer/normalizeStyle\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Theme, { ThemeShape } from \"./Theme\";\nimport { resolveComponentStyle } from \"./resolveComponentStyle\";\nvar themeCache = {};\nexport function clearThemeCache() {\n  themeCache = {};\n}\n\nfunction throwConnectStyleError(errorMessage, componentDisplayName) {\n  throw Error(\"\".concat(errorMessage, \" - when connecting \").concat(componentDisplayName, \" component to style.\"));\n}\n\nfunction getTheme(context) {\n  return context.theme || Theme.getDefaultTheme();\n}\n\nfunction isStyleVariant(propertyName) {\n  return /^\\./.test(propertyName);\n}\n\nfunction isChildStyle(propertyName) {\n  return /(^[^\\.].*\\.)|^\\*$/.test(propertyName);\n}\n\nfunction getConcreteStyle(style) {\n  return _.pickBy(style, (value, key) => {\n    return !isStyleVariant(key) && !isChildStyle(key);\n  });\n}\n\nexport default (function (componentStyleName) {\n  var componentStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var mapPropsToStyleNames = arguments.length > 2 ? arguments[2] : undefined;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  function getComponentDisplayName(WrappedComponent) {\n    return WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n  }\n\n  return function wrapWithStyledComponent(WrappedComponent) {\n    var componentDisplayName = getComponentDisplayName(WrappedComponent);\n\n    if (!_.isPlainObject(componentStyle)) {\n      throwConnectStyleError(\"Component style must be plain object\", componentDisplayName);\n    }\n\n    if (!_.isString(componentStyleName)) {\n      throwConnectStyleError(\"Component Style Name must be string\", componentDisplayName);\n    }\n\n    class StyledComponent extends React.Component {\n      constructor(props, context) {\n        super(props, context);\n        var styleNames = this.getStyleNames(props);\n        var style = props.style;\n        var finalStyle = this.getFinalStyle(props, context, style, styleNames);\n        this.setWrappedInstance = this.setWrappedInstance.bind(this);\n        this.resolveConnectedComponentStyle = this.resolveConnectedComponentStyle.bind(this);\n        this.state = {\n          style: finalStyle,\n          addedProps: this.resolveAddedProps(),\n          styleNames\n        };\n      }\n\n      getFinalStyle(props, context, style, styleNames) {\n        var resolvedStyle = {};\n\n        if (context.parentPath) {\n          resolvedStyle = this.getOrSetStylesInCache(context, props, styleNames, [...context.parentPath, componentStyleName, ...styleNames]);\n        } else {\n          resolvedStyle = this.resolveStyle(context, props, styleNames);\n          themeCache[componentStyleName] = resolvedStyle;\n        }\n\n        var concreteStyle = getConcreteStyle(_.merge({}, resolvedStyle));\n\n        if (_.isArray(style)) {\n          return [concreteStyle, ...style];\n        }\n\n        if (typeof style == \"number\" || typeof style == \"object\") {\n          return [concreteStyle, style];\n        }\n\n        return concreteStyle;\n      }\n\n      getStyleNames(props) {\n        var styleNamesArr = _.map(props, (value, key) => {\n          if (typeof value !== \"object\" && value === true) {\n            return \".\" + key;\n          } else {\n            return false;\n          }\n        });\n\n        _.remove(styleNamesArr, (value, index) => {\n          return value === false;\n        });\n\n        return styleNamesArr;\n      }\n\n      getParentPath() {\n        if (!this.context.parentPath) {\n          return [componentStyleName];\n        } else {\n          return [...this.context.parentPath, componentStyleName, ...this.getStyleNames(this.props)];\n        }\n      }\n\n      getChildContext() {\n        return {\n          parentPath: this.getParentPath()\n        };\n      }\n\n      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {\n        var styleNames = this.getStyleNames(nextProps);\n        var style = nextProps.style;\n\n        if (this.shouldRebuildStyle(nextProps, nextContext, styleNames)) {\n          var finalStyle = this.getFinalStyle(nextProps, nextContext, style, styleNames);\n          this.setState({\n            style: finalStyle,\n            styleNames\n          });\n        }\n      }\n\n      setNativeProps(nativeProps) {\n        if (this.wrappedInstance.setNativeProps) {\n          this.wrappedInstance.setNativeProps(nativeProps);\n        }\n      }\n\n      setWrappedInstance(component) {\n        if (component && component._root) {\n          this._root = component._root;\n        } else {\n          this._root = component;\n        }\n\n        this.wrappedInstance = this._root;\n      }\n\n      hasStyleNameChanged(nextProps, styleNames) {\n        return mapPropsToStyleNames && this.props !== nextProps && !_.isEqual(this.state.styleNames, styleNames);\n      }\n\n      shouldRebuildStyle(nextProps, nextContext, styleNames) {\n        return nextProps.style !== this.props.style || nextProps.styleName !== this.props.styleName || nextContext.theme !== this.context.theme || !_.isEqual(nextContext.parentPath, this.context.parentPath) || this.hasStyleNameChanged(nextProps, styleNames);\n      }\n\n      resolveStyleNames(props) {\n        var {\n          styleName\n        } = props;\n        var styleNames = styleName ? styleName.split(/\\s/g) : [];\n\n        if (!mapPropsToStyleNames) {\n          return styleNames;\n        }\n\n        return _.uniq(mapPropsToStyleNames(styleNames, props));\n      }\n\n      resolveAddedProps() {\n        var addedProps = {};\n\n        if (options.withRef) {\n          addedProps.ref = \"wrappedInstance\";\n        }\n\n        return addedProps;\n      }\n\n      getOrSetStylesInCache(context, props, styleNames, path) {\n        if (themeCache && themeCache[path.join(\">\")]) {\n          return themeCache[path.join(\">\")];\n        } else {\n          var resolvedStyle = this.resolveStyle(context, props, styleNames);\n\n          if (Object.keys(themeCache).length < 10000) {\n            themeCache[path.join(\">\")] = resolvedStyle;\n          }\n\n          return resolvedStyle;\n        }\n      }\n\n      resolveStyle(context, props, styleNames) {\n        var parentStyle = {};\n        var theme = getTheme(context);\n        var themeStyle = theme.createComponentStyle(componentStyleName, componentStyle);\n\n        if (context.parentPath) {\n          parentStyle = themeCache[context.parentPath.join(\">\")];\n        } else {\n          parentStyle = resolveComponentStyle(componentStyleName, styleNames, themeStyle, parentStyle);\n        }\n\n        return resolveComponentStyle(componentStyleName, styleNames, themeStyle, parentStyle);\n      }\n\n      resolveConnectedComponentStyle(props) {\n        var styleNames = this.resolveStyleNames(props);\n        return this.resolveStyle(this.context, props, styleNames).componentStyle;\n      }\n\n      render() {\n        var {\n          addedProps,\n          style\n        } = this.state;\n        return React.createElement(WrappedComponent, _extends({}, this.props, addedProps, {\n          style: style,\n          ref: this.setWrappedInstance,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 392,\n            columnNumber: 11\n          }\n        }));\n      }\n\n    }\n\n    StyledComponent.contextTypes = {\n      theme: ThemeShape,\n      parentPath: PropTypes.array\n    };\n    StyledComponent.childContextTypes = {\n      parentPath: PropTypes.array\n    };\n    StyledComponent.propTypes = {\n      style: PropTypes.oneOfType([PropTypes.object, PropTypes.number, PropTypes.array]),\n      styleName: PropTypes.string,\n      virtual: PropTypes.bool\n    };\n    StyledComponent.defaultProps = {\n      virtual: options.virtual\n    };\n    StyledComponent.displayName = \"Styled(\".concat(componentDisplayName, \")\");\n    StyledComponent.WrappedComponent = WrappedComponent;\n    return hoistStatics(StyledComponent, WrappedComponent);\n  };\n});","map":{"version":3,"sources":["/Users/m.asyam/Desktop/MY-PROJECTS/react-project/client-pack/node_modules/native-base-shoutem-theme/src/connectStyle.js"],"names":["React","PropTypes","hoistStatics","_","normalizeStyle","Theme","ThemeShape","resolveComponentStyle","themeCache","clearThemeCache","throwConnectStyleError","errorMessage","componentDisplayName","Error","getTheme","context","theme","getDefaultTheme","isStyleVariant","propertyName","test","isChildStyle","getConcreteStyle","style","pickBy","value","key","componentStyleName","componentStyle","mapPropsToStyleNames","options","getComponentDisplayName","WrappedComponent","displayName","name","wrapWithStyledComponent","isPlainObject","isString","StyledComponent","Component","constructor","props","styleNames","getStyleNames","finalStyle","getFinalStyle","setWrappedInstance","bind","resolveConnectedComponentStyle","state","addedProps","resolveAddedProps","resolvedStyle","parentPath","getOrSetStylesInCache","resolveStyle","concreteStyle","merge","isArray","styleNamesArr","map","remove","index","getParentPath","getChildContext","UNSAFE_componentWillReceiveProps","nextProps","nextContext","shouldRebuildStyle","setState","setNativeProps","nativeProps","wrappedInstance","component","_root","hasStyleNameChanged","isEqual","styleName","resolveStyleNames","split","uniq","withRef","ref","path","join","Object","keys","length","parentStyle","themeStyle","createComponentStyle","render","contextTypes","array","childContextTypes","propTypes","oneOfType","object","number","string","virtual","bool","defaultProps"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport hoistStatics from 'hoist-non-react-statics';\nimport * as _ from 'lodash';\nimport normalizeStyle from './StyleNormalizer/normalizeStyle';\nimport { StyleSheet } from \"react-native\";\n\nimport Theme, { ThemeShape } from \"./Theme\";\nimport { resolveComponentStyle } from \"./resolveComponentStyle\";\n\nlet themeCache = {};\n\n/**\n * clear theme cache\n * @export\n */\nexport function clearThemeCache() {\n  themeCache = {};\n}\n\n/**\n * Formats and throws an error when connecting component style with the theme.\n *\n * @param errorMessage The error message.\n * @param componentDisplayName The name of the component that is being connected.\n */\nfunction throwConnectStyleError(errorMessage, componentDisplayName) {\n  throw Error(\n    `${errorMessage} - when connecting ${componentDisplayName} component to style.`\n  );\n}\n\n/**\n * Returns the theme object from the provided context,\n * or an empty theme if the context doesn't contain a theme.\n *\n * @param context The React component context.\n * @returns {Theme} The Theme object.\n */\nfunction getTheme(context) {\n  // Fallback to a default theme if the component isn't\n  // rendered in a StyleProvider.\n  return context.theme || Theme.getDefaultTheme();\n}\n\n/**\n * Matches any style properties that represent component style variants.\n * Those styles can be applied to the component by using the styleName\n * prop. All style variant property names must start with a single '.'\n * character, e.g., '.variant'.\n *\n * @param propertyName The style property name.\n * @returns {boolean} True if the style property represents a component variant, false otherwise.\n */\nfunction isStyleVariant(propertyName) {\n  return /^\\./.test(propertyName);\n}\n\n/**\n * Matches any style properties that represent style rules that target the\n * component children. Those styles can have two formats, they can either\n * target the components by component name ('shoutem.ui.Text'), or by component\n * name and variant ('shoutem.ui.Text.line-through'). Beside specifying the\n * component name, those styles can also target any component by using the\n * '*' wildcard ('*', or '*.line-through'). The rule to identify those styles is\n * that they have to contain a '.' character in their name or be a '*'.\n *\n * @param propertyName The style property name.\n * @returns {boolean} True if the style property represents a child style, false otherwise.\n */\nfunction isChildStyle(propertyName) {\n  return /(^[^\\.].*\\.)|^\\*$/.test(propertyName);\n}\n\nfunction getConcreteStyle(style) {\n  return _.pickBy(style, (value, key) => {\n    return !isStyleVariant(key) && !isChildStyle(key);\n  });\n}\n\n/**\n * Resolves the final component style by using the theme style, if available and\n * merging it with the style provided directly through the style prop, and style\n * variants applied through the styleName prop.\n *\n * @param componentStyleName The component name that will be used\n * to target this component in style rules.\n * @param componentStyle The default component style.\n * @param mapPropsToStyleNames Pure function to customize styleNames depending on props.\n * @param options The additional connectStyle options\n * @param options.virtual The default value of the virtual prop\n * @param options.withRef Create component ref with addedProps; if true, ref name is wrappedInstance\n * @returns {StyledComponent} The new component that will handle\n * the styling of the wrapped component.\n */\nexport default (\n  componentStyleName,\n  componentStyle = {},\n  mapPropsToStyleNames,\n  options = {}\n) => {\n  function getComponentDisplayName(WrappedComponent) {\n    return WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n  }\n\n  return function wrapWithStyledComponent(WrappedComponent) {\n    const componentDisplayName = getComponentDisplayName(WrappedComponent);\n\n    if (!_.isPlainObject(componentStyle)) {\n      throwConnectStyleError(\n        \"Component style must be plain object\",\n        componentDisplayName\n      );\n    }\n\n    if (!_.isString(componentStyleName)) {\n      throwConnectStyleError(\n        \"Component Style Name must be string\",\n        componentDisplayName\n      );\n    }\n\n    class StyledComponent extends React.Component {\n      static contextTypes = {\n        theme: ThemeShape,\n        // The style inherited from the parent\n        // parentStyle: PropTypes.object,\n        parentPath: PropTypes.array\n      };\n\n      static childContextTypes = {\n        // Provide the parent style to child components\n        // parentStyle: PropTypes.object,\n        // resolveStyle: PropTypes.func,\n        parentPath: PropTypes.array\n      };\n\n      static propTypes = {\n        // Element style that overrides any other style of the component\n        style: PropTypes.oneOfType([\n          PropTypes.object,\n          PropTypes.number,\n          PropTypes.array\n        ]),\n        // The style variant names to apply to this component,\n        // multiple variants may be separated with a space character\n        styleName: PropTypes.string,\n        // Virtual elements will propagate the parent\n        // style to their children, i.e., the children\n        // will behave as they are placed directly below\n        // the parent of a virtual element.\n        virtual: PropTypes.bool\n      };\n\n      static defaultProps = {\n        virtual: options.virtual\n      };\n\n      static displayName = `Styled(${componentDisplayName})`;\n      static WrappedComponent = WrappedComponent;\n\n      constructor(props, context) {\n        super(props, context);\n        // console.log(context.parentPath);\n        const styleNames = this.getStyleNames(props);\n        const style = props.style;\n\n        const finalStyle = this.getFinalStyle(\n          props,\n          context,\n          style,\n          styleNames\n        );\n\n        this.setWrappedInstance = this.setWrappedInstance.bind(this);\n        this.resolveConnectedComponentStyle = this.resolveConnectedComponentStyle.bind(\n          this\n        );\n        this.state = {\n          style: finalStyle,\n          // AddedProps are additional WrappedComponent props\n          // Usually they are set trough alternative ways,\n          // such as theme style, or trough options\n          addedProps: this.resolveAddedProps(),\n          styleNames\n        };\n      }\n\n      getFinalStyle(props, context, style, styleNames) {\n        let resolvedStyle = {};\n        if (context.parentPath) {\n          resolvedStyle = this.getOrSetStylesInCache(\n            context,\n            props,\n            styleNames,\n            [...context.parentPath, componentStyleName, ...styleNames]\n          );\n        } else {\n          resolvedStyle = this.resolveStyle(context, props, styleNames);\n          themeCache[componentStyleName] = resolvedStyle;\n        }\n\n        const concreteStyle = getConcreteStyle(_.merge({}, resolvedStyle));\n\n        if (_.isArray(style)) {\n          return [concreteStyle, ...style];\n        }\n\n        if (typeof style == \"number\" || typeof style == \"object\") {\n          return [concreteStyle, style];\n        }\n\n        return concreteStyle;\n      }\n\n      getStyleNames(props) {\n        const styleNamesArr = _.map(props, (value, key) => {\n          if (typeof value !== \"object\" && value === true) {\n            return \".\" + key;\n          } else {\n            return false;\n          }\n        });\n        _.remove(styleNamesArr, (value, index) => {\n          return value === false;\n        });\n\n        return styleNamesArr;\n      }\n\n      getParentPath() {\n        if (!this.context.parentPath) {\n          return [componentStyleName];\n        } else {\n          return [\n            ...this.context.parentPath,\n            componentStyleName,\n            ...this.getStyleNames(this.props)\n          ];\n        }\n      }\n\n      getChildContext() {\n        return {\n          // parentStyle: this.props.virtual ?\n          //   this.context.parentStyle :\n          //   this.state.childrenStyle,\n          // resolveStyle: this.resolveConnectedComponentStyle,\n          parentPath: this.getParentPath()\n        };\n      }\n\n      UNSAFE_componentWillReceiveProps(nextProps, nextContext) {\n        const styleNames = this.getStyleNames(nextProps);\n        const style = nextProps.style;\n        if (this.shouldRebuildStyle(nextProps, nextContext, styleNames)) {\n          const finalStyle = this.getFinalStyle(\n            nextProps,\n            nextContext,\n            style,\n            styleNames\n          );\n\n          this.setState({\n            style: finalStyle,\n            // childrenStyle: resolvedStyle.childrenStyle,\n            styleNames\n          });\n        }\n      }\n\n      setNativeProps(nativeProps) {\n        if (this.wrappedInstance.setNativeProps) {\n          this.wrappedInstance.setNativeProps(nativeProps);\n        }\n      }\n\n      setWrappedInstance(component) {\n        if (component && component._root) {\n          this._root = component._root;\n        } else {\n          this._root = component;\n        }\n        this.wrappedInstance = this._root;\n      }\n\n      hasStyleNameChanged(nextProps, styleNames) {\n        return (\n          mapPropsToStyleNames &&\n          this.props !== nextProps &&\n          // Even though props did change here,\n          // it doesn't necessary means changed props are those which affect styleName\n          !_.isEqual(this.state.styleNames, styleNames)\n        );\n      }\n\n      shouldRebuildStyle(nextProps, nextContext, styleNames) {\n        return (\n          nextProps.style !== this.props.style ||\n          nextProps.styleName !== this.props.styleName ||\n          nextContext.theme !== this.context.theme ||\n          !_.isEqual(nextContext.parentPath, this.context.parentPath) ||\n          this.hasStyleNameChanged(nextProps, styleNames)\n        );\n      }\n\n      resolveStyleNames(props) {\n        const { styleName } = props;\n        const styleNames = styleName ? styleName.split(/\\s/g) : [];\n\n        if (!mapPropsToStyleNames) {\n          return styleNames;\n        }\n\n        // We only want to keep the unique style names\n        return _.uniq(mapPropsToStyleNames(styleNames, props));\n      }\n\n      resolveAddedProps() {\n        const addedProps = {};\n        if (options.withRef) {\n          addedProps.ref = \"wrappedInstance\";\n        }\n        return addedProps;\n      }\n\n      getOrSetStylesInCache(context, props, styleNames, path) {\n        if (themeCache && themeCache[path.join(\">\")]) {\n          // console.log('**************');\n\n          return themeCache[path.join(\">\")];\n        } else {\n          const resolvedStyle = this.resolveStyle(context, props, styleNames);\n          if (Object.keys(themeCache).length < 10000) {\n            themeCache[path.join(\">\")] = resolvedStyle;\n          }\n          return resolvedStyle;\n        }\n      }\n\n      resolveStyle(context, props, styleNames) {\n        let parentStyle = {};\n\n        const theme = getTheme(context);\n        const themeStyle = theme.createComponentStyle(\n          componentStyleName,\n          componentStyle\n        );\n\n        if (context.parentPath) {\n          parentStyle = themeCache[context.parentPath.join(\">\")];\n        } else {\n          parentStyle = resolveComponentStyle(\n            componentStyleName,\n            styleNames,\n            themeStyle,\n            parentStyle\n          );\n        }\n\n        return resolveComponentStyle(\n          componentStyleName,\n          styleNames,\n          themeStyle,\n          parentStyle\n        );\n      }\n\n      /**\n       * A helper function provided to child components that enables\n       * them to resolve their style for any set of prop values.\n       *\n       * @param props The component props to use to resolve the style values.\n       * @returns {*} The resolved component style.\n       */\n      resolveConnectedComponentStyle(props) {\n        const styleNames = this.resolveStyleNames(props);\n        return this.resolveStyle(this.context, props, styleNames)\n          .componentStyle;\n      }\n\n      render() {\n        // console.log('themeCache', themeCache);\n\n        // if(componentStyleName == 'NativeBase.Text') {\n        //   console.log(this.state.style);\n        //   console.log(themeCache);\n        // }\n\n        const { addedProps, style } = this.state;\n        return (\n          <WrappedComponent\n            {...this.props}\n            {...addedProps}\n            style={style}\n            ref={this.setWrappedInstance}\n          />\n        );\n      }\n    }\n\n    return hoistStatics(StyledComponent, WrappedComponent);\n  };\n};\n"]},"metadata":{},"sourceType":"module"}