{"ast":null,"code":"var _jsxFileName = \"/Users/m.asyam/Desktop/MY-PROJECTS/react-project/client-pack/node_modules/react-native-snap-carousel/src/carousel/Carousel.js\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport FlatList from \"react-native-web/dist/exports/FlatList\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nimport View from \"react-native-web/dist/exports/View\";\nimport ViewPropTypes from \"react-native-web/dist/exports/ViewPropTypes\";\nimport PropTypes from 'prop-types';\nimport shallowCompare from 'react-addons-shallow-compare';\nimport { defaultScrollInterpolator, stackScrollInterpolator, tinderScrollInterpolator, defaultAnimatedStyles, shiftAnimatedStyles, stackAnimatedStyles, tinderAnimatedStyles } from \"../utils/animations\";\nvar IS_IOS = Platform.OS === 'ios';\nvar AnimatedFlatList = FlatList ? Animated.createAnimatedComponent(FlatList) : null;\nvar AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);\nvar IS_RTL = I18nManager.isRTL;\nexport default class Carousel extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      hideCarousel: true,\n      interpolators: []\n    };\n\n    var initialActiveItem = this._getFirstItem(props.firstItem);\n\n    this._activeItem = initialActiveItem;\n    this._previousActiveItem = initialActiveItem;\n    this._previousFirstItem = initialActiveItem;\n    this._previousItemsLength = initialActiveItem;\n    this._mounted = false;\n    this._positions = [];\n    this._currentContentOffset = 0;\n    this._canFireBeforeCallback = false;\n    this._canFireCallback = false;\n    this._scrollOffsetRef = null;\n    this._onScrollTriggered = true;\n    this._lastScrollDate = 0;\n    this._scrollEnabled = props.scrollEnabled !== false;\n    this._initPositionsAndInterpolators = this._initPositionsAndInterpolators.bind(this);\n    this._renderItem = this._renderItem.bind(this);\n    this._onSnap = this._onSnap.bind(this);\n    this._onLayout = this._onLayout.bind(this);\n    this._onScroll = this._onScroll.bind(this);\n    this._onScrollBeginDrag = props.enableSnap ? this._onScrollBeginDrag.bind(this) : undefined;\n    this._onScrollEnd = props.enableSnap || props.autoplay ? this._onScrollEnd.bind(this) : undefined;\n    this._onScrollEndDrag = !props.enableMomentum ? this._onScrollEndDrag.bind(this) : undefined;\n    this._onMomentumScrollEnd = props.enableMomentum ? this._onMomentumScrollEnd.bind(this) : undefined;\n    this._onTouchStart = this._onTouchStart.bind(this);\n    this._onTouchEnd = this._onTouchEnd.bind(this);\n    this._onTouchRelease = this._onTouchRelease.bind(this);\n    this._getKeyExtractor = this._getKeyExtractor.bind(this);\n\n    this._setScrollHandler(props);\n\n    this._ignoreNextMomentum = false;\n\n    if (!ViewPropTypes) {\n      console.warn('react-native-snap-carousel: It is recommended to use at least version 0.44 of React Native with the plugin');\n    }\n\n    if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {\n      console.error('react-native-snap-carousel: You need to specify both `sliderWidth` and `itemWidth` for horizontal carousels');\n    }\n\n    if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {\n      console.error('react-native-snap-carousel: You need to specify both `sliderHeight` and `itemHeight` for vertical carousels');\n    }\n\n    if (props.apparitionDelay && !IS_IOS && !props.useScrollView) {\n      console.warn('react-native-snap-carousel: Using `apparitionDelay` on Android is not recommended since it can lead to rendering issues');\n    }\n\n    if (props.customAnimationType || props.customAnimationOptions) {\n      console.warn('react-native-snap-carousel: Props `customAnimationType` and `customAnimationOptions` have been renamed to `activeAnimationType` and `activeAnimationOptions`');\n    }\n\n    if (props.onScrollViewScroll) {\n      console.error('react-native-snap-carousel: Prop `onScrollViewScroll` has been removed. Use `onScroll` instead');\n    }\n  }\n\n  componentDidMount() {\n    var {\n      apparitionDelay,\n      autoplay,\n      firstItem\n    } = this.props;\n\n    var _firstItem = this._getFirstItem(firstItem);\n\n    var apparitionCallback = () => {\n      this.setState({\n        hideCarousel: false\n      });\n\n      if (autoplay) {\n        this.startAutoplay();\n      }\n    };\n\n    this._mounted = true;\n\n    this._initPositionsAndInterpolators();\n\n    requestAnimationFrame(() => {\n      if (!this._mounted) {\n        return;\n      }\n\n      this._snapToItem(_firstItem, false, false, true, false);\n\n      this._hackActiveSlideAnimation(_firstItem, 'start', true);\n\n      if (apparitionDelay) {\n        this._apparitionTimeout = setTimeout(() => {\n          apparitionCallback();\n        }, apparitionDelay);\n      } else {\n        apparitionCallback();\n      }\n    });\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if (this.props.shouldOptimizeUpdates === false) {\n      return true;\n    } else {\n      return shallowCompare(this, nextProps, nextState);\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    var {\n      interpolators\n    } = this.state;\n    var {\n      firstItem,\n      itemHeight,\n      itemWidth,\n      scrollEnabled,\n      sliderHeight,\n      sliderWidth\n    } = this.props;\n\n    var itemsLength = this._getCustomDataLength(this.props);\n\n    if (!itemsLength) {\n      return;\n    }\n\n    var nextFirstItem = this._getFirstItem(firstItem, this.props);\n\n    var nextActiveItem = this._activeItem || this._activeItem === 0 ? this._activeItem : nextFirstItem;\n    var hasNewSliderWidth = sliderWidth && sliderWidth !== prevProps.sliderWidth;\n    var hasNewSliderHeight = sliderHeight && sliderHeight !== prevProps.sliderHeight;\n    var hasNewItemWidth = itemWidth && itemWidth !== prevProps.itemWidth;\n    var hasNewItemHeight = itemHeight && itemHeight !== prevProps.itemHeight;\n    var hasNewScrollEnabled = scrollEnabled !== prevProps.scrollEnabled;\n\n    if (nextActiveItem > itemsLength - 1) {\n      nextActiveItem = itemsLength - 1;\n    }\n\n    if (hasNewScrollEnabled) {\n      this._setScrollEnabled(scrollEnabled);\n    }\n\n    if (interpolators.length !== itemsLength || hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n      this._activeItem = nextActiveItem;\n      this._previousItemsLength = itemsLength;\n\n      this._initPositionsAndInterpolators(this.props);\n\n      if (this._previousItemsLength > itemsLength) {\n        this._hackActiveSlideAnimation(nextActiveItem, null, true);\n      }\n\n      if (hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n        this._snapToItem(nextActiveItem, false, false, false, false);\n      }\n    } else if (nextFirstItem !== this._previousFirstItem && nextFirstItem !== this._activeItem) {\n      this._activeItem = nextFirstItem;\n      this._previousFirstItem = nextFirstItem;\n\n      this._snapToItem(nextFirstItem, false, true, false, false);\n    }\n\n    if (this.props.onScroll !== prevProps.onScroll) {\n      this._setScrollHandler(this.props);\n    }\n  }\n\n  componentWillUnmount() {\n    this._mounted = false;\n    this.stopAutoplay();\n    clearTimeout(this._apparitionTimeout);\n    clearTimeout(this._hackSlideAnimationTimeout);\n    clearTimeout(this._enableAutoplayTimeout);\n    clearTimeout(this._autoplayTimeout);\n    clearTimeout(this._snapNoMomentumTimeout);\n    clearTimeout(this._edgeItemTimeout);\n    clearTimeout(this._lockScrollTimeout);\n  }\n\n  get realIndex() {\n    return this._activeItem;\n  }\n\n  get currentIndex() {\n    return this._getDataIndex(this._activeItem);\n  }\n\n  get currentScrollPosition() {\n    return this._currentContentOffset;\n  }\n\n  _setScrollHandler(props) {\n    var scrollEventConfig = {\n      listener: this._onScroll,\n      useNativeDriver: true\n    };\n    this._scrollPos = new Animated.Value(0);\n    var argMapping = props.vertical ? [{\n      nativeEvent: {\n        contentOffset: {\n          y: this._scrollPos\n        }\n      }\n    }] : [{\n      nativeEvent: {\n        contentOffset: {\n          x: this._scrollPos\n        }\n      }\n    }];\n\n    if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {\n      argMapping.pop();\n      var [argMap] = props.onScroll._argMapping;\n\n      if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {\n        this._scrollPos = argMap.nativeEvent.contentOffset.x || argMap.nativeEvent.contentOffset.y || this._scrollPos;\n      }\n\n      argMapping.push(...props.onScroll._argMapping);\n    }\n\n    this._onScrollHandler = Animated.event(argMapping, scrollEventConfig);\n  }\n\n  _needsScrollView() {\n    var {\n      useScrollView\n    } = this.props;\n    return useScrollView || !AnimatedFlatList || this._shouldUseStackLayout() || this._shouldUseTinderLayout();\n  }\n\n  _needsRTLAdaptations() {\n    var {\n      vertical\n    } = this.props;\n    return IS_RTL && !IS_IOS && !vertical;\n  }\n\n  _canLockScroll() {\n    var {\n      scrollEnabled,\n      enableMomentum,\n      lockScrollWhileSnapping\n    } = this.props;\n    return scrollEnabled && !enableMomentum && lockScrollWhileSnapping;\n  }\n\n  _enableLoop() {\n    var {\n      data,\n      enableSnap,\n      loop\n    } = this.props;\n    return enableSnap && loop && data && data.length && data.length > 1;\n  }\n\n  _shouldAnimateSlides() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n    var {\n      inactiveSlideOpacity,\n      inactiveSlideScale,\n      scrollInterpolator,\n      slideInterpolatedStyle\n    } = props;\n    return inactiveSlideOpacity < 1 || inactiveSlideScale < 1 || !!scrollInterpolator || !!slideInterpolatedStyle || this._shouldUseShiftLayout() || this._shouldUseStackLayout() || this._shouldUseTinderLayout();\n  }\n\n  _shouldUseCustomAnimation() {\n    var {\n      activeAnimationOptions\n    } = this.props;\n    return !!activeAnimationOptions && !this._shouldUseStackLayout() && !this._shouldUseTinderLayout();\n  }\n\n  _shouldUseShiftLayout() {\n    var {\n      inactiveSlideShift,\n      layout\n    } = this.props;\n    return layout === 'default' && inactiveSlideShift !== 0;\n  }\n\n  _shouldUseStackLayout() {\n    return this.props.layout === 'stack';\n  }\n\n  _shouldUseTinderLayout() {\n    return this.props.layout === 'tinder';\n  }\n\n  _getCustomData() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n    var {\n      data,\n      loopClonesPerSide\n    } = props;\n    var dataLength = data && data.length;\n\n    if (!dataLength) {\n      return [];\n    }\n\n    if (!this._enableLoop()) {\n      return data;\n    }\n\n    var previousItems = [];\n    var nextItems = [];\n\n    if (loopClonesPerSide > dataLength) {\n      var dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n      var remainder = loopClonesPerSide % dataLength;\n\n      for (var i = 0; i < dataMultiplier; i++) {\n        previousItems.push(...data);\n        nextItems.push(...data);\n      }\n\n      previousItems.unshift(...data.slice(-remainder));\n      nextItems.push(...data.slice(0, remainder));\n    } else {\n      previousItems = data.slice(-loopClonesPerSide);\n      nextItems = data.slice(0, loopClonesPerSide);\n    }\n\n    return previousItems.concat(data, nextItems);\n  }\n\n  _getCustomDataLength() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n    var {\n      data,\n      loopClonesPerSide\n    } = props;\n    var dataLength = data && data.length;\n\n    if (!dataLength) {\n      return 0;\n    }\n\n    return this._enableLoop() ? dataLength + 2 * loopClonesPerSide : dataLength;\n  }\n\n  _getCustomIndex(index) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;\n\n    var itemsLength = this._getCustomDataLength(props);\n\n    if (!itemsLength || !index && index !== 0) {\n      return 0;\n    }\n\n    return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;\n  }\n\n  _getDataIndex(index) {\n    var {\n      data,\n      loopClonesPerSide\n    } = this.props;\n    var dataLength = data && data.length;\n\n    if (!this._enableLoop() || !dataLength) {\n      return index;\n    }\n\n    if (index >= dataLength + loopClonesPerSide) {\n      return loopClonesPerSide > dataLength ? (index - loopClonesPerSide) % dataLength : index - dataLength - loopClonesPerSide;\n    } else if (index < loopClonesPerSide) {\n      if (loopClonesPerSide > dataLength) {\n        var baseDataIndexes = [];\n        var dataIndexes = [];\n        var dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n        var remainder = loopClonesPerSide % dataLength;\n\n        for (var i = 0; i < dataLength; i++) {\n          baseDataIndexes.push(i);\n        }\n\n        for (var j = 0; j < dataMultiplier; j++) {\n          dataIndexes.push(...baseDataIndexes);\n        }\n\n        dataIndexes.unshift(...baseDataIndexes.slice(-remainder));\n        return dataIndexes[index];\n      } else {\n        return index + dataLength - loopClonesPerSide;\n      }\n    } else {\n      return index - loopClonesPerSide;\n    }\n  }\n\n  _getPositionIndex(index) {\n    var {\n      loop,\n      loopClonesPerSide\n    } = this.props;\n    return loop ? index + loopClonesPerSide : index;\n  }\n\n  _getFirstItem(index) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;\n    var {\n      loopClonesPerSide\n    } = props;\n\n    var itemsLength = this._getCustomDataLength(props);\n\n    if (!itemsLength || index > itemsLength - 1 || index < 0) {\n      return 0;\n    }\n\n    return this._enableLoop() ? index + loopClonesPerSide : index;\n  }\n\n  _getWrappedRef() {\n    if (this._carouselRef && (this._needsScrollView() && this._carouselRef.scrollTo || !this._needsScrollView() && this._carouselRef.scrollToOffset)) {\n      return this._carouselRef;\n    }\n\n    return this._carouselRef && this._carouselRef.getNode && this._carouselRef.getNode();\n  }\n\n  _getScrollEnabled() {\n    return this._scrollEnabled;\n  }\n\n  _setScrollEnabled() {\n    var scrollEnabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    var wrappedRef = this._getWrappedRef();\n\n    if (!wrappedRef || !wrappedRef.setNativeProps) {\n      return;\n    }\n\n    wrappedRef.setNativeProps({\n      scrollEnabled\n    });\n    this._scrollEnabled = scrollEnabled;\n  }\n\n  _getKeyExtractor(item, index) {\n    return this._needsScrollView() ? \"scrollview-item-\".concat(index) : \"flatlist-item-\".concat(index);\n  }\n\n  _getScrollOffset(event) {\n    var {\n      vertical\n    } = this.props;\n    return event && event.nativeEvent && event.nativeEvent.contentOffset && event.nativeEvent.contentOffset[vertical ? 'y' : 'x'] || 0;\n  }\n\n  _getContainerInnerMargin() {\n    var opposite = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var {\n      sliderWidth,\n      sliderHeight,\n      itemWidth,\n      itemHeight,\n      vertical,\n      activeSlideAlignment\n    } = this.props;\n\n    if (activeSlideAlignment === 'start' && !opposite || activeSlideAlignment === 'end' && opposite) {\n      return 0;\n    } else if (activeSlideAlignment === 'end' && !opposite || activeSlideAlignment === 'start' && opposite) {\n      return vertical ? sliderHeight - itemHeight : sliderWidth - itemWidth;\n    } else {\n      return vertical ? (sliderHeight - itemHeight) / 2 : (sliderWidth - itemWidth) / 2;\n    }\n  }\n\n  _getViewportOffset() {\n    var {\n      sliderWidth,\n      sliderHeight,\n      itemWidth,\n      itemHeight,\n      vertical,\n      activeSlideAlignment\n    } = this.props;\n\n    if (activeSlideAlignment === 'start') {\n      return vertical ? itemHeight / 2 : itemWidth / 2;\n    } else if (activeSlideAlignment === 'end') {\n      return vertical ? sliderHeight - itemHeight / 2 : sliderWidth - itemWidth / 2;\n    } else {\n      return vertical ? sliderHeight / 2 : sliderWidth / 2;\n    }\n  }\n\n  _getCenter(offset) {\n    return offset + this._getViewportOffset() - this._getContainerInnerMargin();\n  }\n\n  _getActiveItem(offset) {\n    var {\n      activeSlideOffset,\n      swipeThreshold\n    } = this.props;\n\n    var center = this._getCenter(offset);\n\n    var centerOffset = activeSlideOffset || swipeThreshold;\n\n    for (var i = 0; i < this._positions.length; i++) {\n      var {\n        start,\n        end\n      } = this._positions[i];\n\n      if (center + centerOffset >= start && center - centerOffset <= end) {\n        return i;\n      }\n    }\n\n    var lastIndex = this._positions.length - 1;\n\n    if (this._positions[lastIndex] && center - centerOffset > this._positions[lastIndex].end) {\n      return lastIndex;\n    }\n\n    return 0;\n  }\n\n  _initPositionsAndInterpolators() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n    var {\n      data,\n      itemWidth,\n      itemHeight,\n      scrollInterpolator,\n      vertical\n    } = props;\n    var sizeRef = vertical ? itemHeight : itemWidth;\n\n    if (!data || !data.length) {\n      return;\n    }\n\n    var interpolators = [];\n    this._positions = [];\n\n    this._getCustomData(props).forEach((itemData, index) => {\n      var _index = this._getCustomIndex(index, props);\n\n      var animatedValue;\n      this._positions[index] = {\n        start: index * sizeRef,\n        end: index * sizeRef + sizeRef\n      };\n\n      if (!this._shouldAnimateSlides(props)) {\n        animatedValue = new Animated.Value(1);\n      } else if (this._shouldUseCustomAnimation()) {\n        animatedValue = new Animated.Value(_index === this._activeItem ? 1 : 0);\n      } else {\n        var interpolator;\n\n        if (scrollInterpolator) {\n          interpolator = scrollInterpolator(_index, props);\n        } else if (this._shouldUseStackLayout()) {\n          interpolator = stackScrollInterpolator(_index, props);\n        } else if (this._shouldUseTinderLayout()) {\n          interpolator = tinderScrollInterpolator(_index, props);\n        }\n\n        if (!interpolator || !interpolator.inputRange || !interpolator.outputRange) {\n          interpolator = defaultScrollInterpolator(_index, props);\n        }\n\n        animatedValue = this._scrollPos.interpolate(_objectSpread(_objectSpread({}, interpolator), {}, {\n          extrapolate: 'clamp'\n        }));\n      }\n\n      interpolators.push(animatedValue);\n    });\n\n    this.setState({\n      interpolators\n    });\n  }\n\n  _getSlideAnimation(index, toValue) {\n    var {\n      interpolators\n    } = this.state;\n    var {\n      activeAnimationType,\n      activeAnimationOptions\n    } = this.props;\n    var animatedValue = interpolators && interpolators[index];\n\n    if (!animatedValue && animatedValue !== 0) {\n      return null;\n    }\n\n    var animationCommonOptions = _objectSpread(_objectSpread({\n      isInteraction: false,\n      useNativeDriver: true\n    }, activeAnimationOptions), {}, {\n      toValue: toValue\n    });\n\n    return Animated.parallel([Animated['timing'](animatedValue, _objectSpread(_objectSpread({}, animationCommonOptions), {}, {\n      easing: Easing.linear\n    })), Animated[activeAnimationType](animatedValue, _objectSpread({}, animationCommonOptions))]);\n  }\n\n  _playCustomSlideAnimation(current, next) {\n    var {\n      interpolators\n    } = this.state;\n\n    var itemsLength = this._getCustomDataLength();\n\n    var _currentIndex = this._getCustomIndex(current);\n\n    var _currentDataIndex = this._getDataIndex(_currentIndex);\n\n    var _nextIndex = this._getCustomIndex(next);\n\n    var _nextDataIndex = this._getDataIndex(_nextIndex);\n\n    var animations = [];\n\n    if (this._enableLoop()) {\n      for (var i = 0; i < itemsLength; i++) {\n        if (this._getDataIndex(i) === _currentDataIndex && interpolators[i]) {\n          animations.push(this._getSlideAnimation(i, 0));\n        } else if (this._getDataIndex(i) === _nextDataIndex && interpolators[i]) {\n          animations.push(this._getSlideAnimation(i, 1));\n        }\n      }\n    } else {\n      if (interpolators[current]) {\n        animations.push(this._getSlideAnimation(current, 0));\n      }\n\n      if (interpolators[next]) {\n        animations.push(this._getSlideAnimation(next, 1));\n      }\n    }\n\n    Animated.parallel(animations, {\n      stopTogether: false\n    }).start();\n  }\n\n  _hackActiveSlideAnimation(index, goTo) {\n    var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var {\n      data\n    } = this.props;\n\n    if (!this._mounted || !this._carouselRef || !this._positions[index] || !force && this._enableLoop()) {\n      return;\n    }\n\n    var offset = this._positions[index] && this._positions[index].start;\n\n    if (!offset && offset !== 0) {\n      return;\n    }\n\n    var itemsLength = data && data.length;\n    var direction = goTo || itemsLength === 1 ? 'start' : 'end';\n\n    this._scrollTo(offset + (direction === 'start' ? -1 : 1), false);\n\n    clearTimeout(this._hackSlideAnimationTimeout);\n    this._hackSlideAnimationTimeout = setTimeout(() => {\n      this._scrollTo(offset, false);\n    }, 50);\n  }\n\n  _lockScroll() {\n    var {\n      lockScrollTimeoutDuration\n    } = this.props;\n    clearTimeout(this._lockScrollTimeout);\n    this._lockScrollTimeout = setTimeout(() => {\n      this._releaseScroll();\n    }, lockScrollTimeoutDuration);\n\n    this._setScrollEnabled(false);\n  }\n\n  _releaseScroll() {\n    clearTimeout(this._lockScrollTimeout);\n\n    this._setScrollEnabled(true);\n  }\n\n  _repositionScroll(index) {\n    var {\n      data,\n      loopClonesPerSide\n    } = this.props;\n    var dataLength = data && data.length;\n\n    if (!this._enableLoop() || !dataLength || index >= loopClonesPerSide && index < dataLength + loopClonesPerSide) {\n      return;\n    }\n\n    var repositionTo = index;\n\n    if (index >= dataLength + loopClonesPerSide) {\n      repositionTo = index - dataLength;\n    } else if (index < loopClonesPerSide) {\n      repositionTo = index + dataLength;\n    }\n\n    this._snapToItem(repositionTo, false, false, false, false);\n  }\n\n  _scrollTo(offset) {\n    var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var {\n      vertical\n    } = this.props;\n\n    var wrappedRef = this._getWrappedRef();\n\n    if (!this._mounted || !wrappedRef) {\n      return;\n    }\n\n    var specificOptions = this._needsScrollView() ? {\n      x: vertical ? 0 : offset,\n      y: vertical ? offset : 0\n    } : {\n      offset\n    };\n\n    var options = _objectSpread(_objectSpread({}, specificOptions), {}, {\n      animated\n    });\n\n    if (this._needsScrollView()) {\n      wrappedRef.scrollTo(options);\n    } else {\n      wrappedRef.scrollToOffset(options);\n    }\n  }\n\n  _onScroll(event) {\n    var {\n      callbackOffsetMargin,\n      enableMomentum,\n      onScroll\n    } = this.props;\n    var scrollOffset = event ? this._getScrollOffset(event) : this._currentContentOffset;\n\n    var nextActiveItem = this._getActiveItem(scrollOffset);\n\n    var itemReached = nextActiveItem === this._itemToSnapTo;\n    var scrollConditions = scrollOffset >= this._scrollOffsetRef - callbackOffsetMargin && scrollOffset <= this._scrollOffsetRef + callbackOffsetMargin;\n    this._currentContentOffset = scrollOffset;\n    this._onScrollTriggered = true;\n    this._lastScrollDate = Date.now();\n\n    if (this._activeItem !== nextActiveItem && this._shouldUseCustomAnimation()) {\n      this._playCustomSlideAnimation(this._activeItem, nextActiveItem);\n    }\n\n    if (enableMomentum) {\n      clearTimeout(this._snapNoMomentumTimeout);\n\n      if (this._activeItem !== nextActiveItem) {\n        this._activeItem = nextActiveItem;\n      }\n\n      if (itemReached) {\n        if (this._canFireBeforeCallback) {\n          this._onBeforeSnap(this._getDataIndex(nextActiveItem));\n        }\n\n        if (scrollConditions && this._canFireCallback) {\n          this._onSnap(this._getDataIndex(nextActiveItem));\n        }\n      }\n    } else if (this._activeItem !== nextActiveItem && itemReached) {\n      if (this._canFireBeforeCallback) {\n        this._onBeforeSnap(this._getDataIndex(nextActiveItem));\n      }\n\n      if (scrollConditions) {\n        this._activeItem = nextActiveItem;\n\n        if (this._canLockScroll()) {\n          this._releaseScroll();\n        }\n\n        if (this._canFireCallback) {\n          this._onSnap(this._getDataIndex(nextActiveItem));\n        }\n      }\n    }\n\n    if (nextActiveItem === this._itemToSnapTo && scrollOffset === this._scrollOffsetRef) {\n      this._repositionScroll(nextActiveItem);\n    }\n\n    if (typeof onScroll === \"function\" && event) {\n      onScroll(event);\n    }\n  }\n\n  _onStartShouldSetResponderCapture(event) {\n    var {\n      onStartShouldSetResponderCapture\n    } = this.props;\n\n    if (onStartShouldSetResponderCapture) {\n      onStartShouldSetResponderCapture(event);\n    }\n\n    return this._getScrollEnabled();\n  }\n\n  _onTouchStart() {\n    var {\n      onTouchStart\n    } = this.props;\n\n    if (this._getScrollEnabled() !== false && this._autoplaying) {\n      this.pauseAutoPlay();\n    }\n\n    if (onTouchStart) {\n      onTouchStart();\n    }\n  }\n\n  _onTouchEnd() {\n    var {\n      onTouchEnd\n    } = this.props;\n\n    if (this._getScrollEnabled() !== false && this._autoplay && !this._autoplaying) {\n      this.startAutoplay();\n    }\n\n    if (onTouchEnd) {\n      onTouchEnd();\n    }\n  }\n\n  _onScrollBeginDrag(event) {\n    var {\n      onScrollBeginDrag\n    } = this.props;\n\n    if (!this._getScrollEnabled()) {\n      return;\n    }\n\n    this._scrollStartOffset = this._getScrollOffset(event);\n    this._scrollStartActive = this._getActiveItem(this._scrollStartOffset);\n    this._ignoreNextMomentum = false;\n\n    if (onScrollBeginDrag) {\n      onScrollBeginDrag(event);\n    }\n  }\n\n  _onScrollEndDrag(event) {\n    var {\n      onScrollEndDrag\n    } = this.props;\n\n    if (this._carouselRef) {\n      this._onScrollEnd && this._onScrollEnd();\n    }\n\n    if (onScrollEndDrag) {\n      onScrollEndDrag(event);\n    }\n  }\n\n  _onMomentumScrollEnd(event) {\n    var {\n      onMomentumScrollEnd\n    } = this.props;\n\n    if (this._carouselRef) {\n      this._onScrollEnd && this._onScrollEnd();\n    }\n\n    if (onMomentumScrollEnd) {\n      onMomentumScrollEnd(event);\n    }\n  }\n\n  _onScrollEnd(event) {\n    var {\n      autoplayDelay,\n      enableSnap\n    } = this.props;\n\n    if (this._ignoreNextMomentum) {\n      this._ignoreNextMomentum = false;\n      return;\n    }\n\n    if (this._currentContentOffset === this._scrollEndOffset) {\n      return;\n    }\n\n    this._scrollEndOffset = this._currentContentOffset;\n    this._scrollEndActive = this._getActiveItem(this._scrollEndOffset);\n\n    if (enableSnap) {\n      this._snapScroll(this._scrollEndOffset - this._scrollStartOffset);\n    }\n\n    if (this._autoplay && !this._autoplaying) {\n      clearTimeout(this._enableAutoplayTimeout);\n      this._enableAutoplayTimeout = setTimeout(() => {\n        this.startAutoplay();\n      }, autoplayDelay + 50);\n    }\n  }\n\n  _onTouchRelease(event) {\n    var {\n      enableMomentum\n    } = this.props;\n\n    if (enableMomentum && IS_IOS) {\n      clearTimeout(this._snapNoMomentumTimeout);\n      this._snapNoMomentumTimeout = setTimeout(() => {\n        this._snapToItem(this._activeItem);\n      }, 100);\n    }\n  }\n\n  _onLayout(event) {\n    var {\n      onLayout\n    } = this.props;\n\n    if (this._onLayoutInitDone) {\n      this._initPositionsAndInterpolators();\n\n      this._snapToItem(this._activeItem, false, false, false, false);\n    } else {\n      this._onLayoutInitDone = true;\n    }\n\n    if (onLayout) {\n      onLayout(event);\n    }\n  }\n\n  _snapScroll(delta) {\n    var {\n      swipeThreshold\n    } = this.props;\n\n    if (!this._scrollEndActive && this._scrollEndActive !== 0 && IS_IOS) {\n      this._scrollEndActive = this._scrollStartActive;\n    }\n\n    if (this._scrollStartActive !== this._scrollEndActive) {\n      this._snapToItem(this._scrollEndActive);\n    } else {\n      if (delta > 0) {\n        if (delta > swipeThreshold) {\n          this._snapToItem(this._scrollStartActive + 1);\n        } else {\n          this._snapToItem(this._scrollEndActive);\n        }\n      } else if (delta < 0) {\n        if (delta < -swipeThreshold) {\n          this._snapToItem(this._scrollStartActive - 1);\n        } else {\n          this._snapToItem(this._scrollEndActive);\n        }\n      } else {\n        this._snapToItem(this._scrollEndActive);\n      }\n    }\n  }\n\n  _snapToItem(index) {\n    var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var fireCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var initial = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var lockScroll = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var {\n      enableMomentum,\n      onSnapToItem,\n      onBeforeSnapToItem\n    } = this.props;\n\n    var itemsLength = this._getCustomDataLength();\n\n    var wrappedRef = this._getWrappedRef();\n\n    if (!itemsLength || !wrappedRef) {\n      return;\n    }\n\n    if (!index || index < 0) {\n      index = 0;\n    } else if (itemsLength > 0 && index >= itemsLength) {\n      index = itemsLength - 1;\n    }\n\n    if (index !== this._previousActiveItem) {\n      this._previousActiveItem = index;\n\n      if (lockScroll && this._canLockScroll()) {\n        this._lockScroll();\n      }\n\n      if (fireCallback) {\n        if (onBeforeSnapToItem) {\n          this._canFireBeforeCallback = true;\n        }\n\n        if (onSnapToItem) {\n          this._canFireCallback = true;\n        }\n      }\n    }\n\n    this._itemToSnapTo = index;\n    this._scrollOffsetRef = this._positions[index] && this._positions[index].start;\n    this._onScrollTriggered = false;\n\n    if (!this._scrollOffsetRef && this._scrollOffsetRef !== 0) {\n      return;\n    }\n\n    this._scrollTo(this._scrollOffsetRef, animated);\n\n    this._scrollEndOffset = this._currentContentOffset;\n\n    if (enableMomentum) {\n      if (!initial) {\n        this._ignoreNextMomentum = true;\n      }\n\n      if (index === 0 || index === itemsLength - 1) {\n        clearTimeout(this._edgeItemTimeout);\n        this._edgeItemTimeout = setTimeout(() => {\n          if (!initial && index === this._activeItem && !this._onScrollTriggered) {\n            this._onScroll();\n          }\n        }, 250);\n      }\n    }\n  }\n\n  _onBeforeSnap(index) {\n    var {\n      onBeforeSnapToItem\n    } = this.props;\n\n    if (!this._carouselRef) {\n      return;\n    }\n\n    this._canFireBeforeCallback = false;\n    onBeforeSnapToItem && onBeforeSnapToItem(index);\n  }\n\n  _onSnap(index) {\n    var {\n      onSnapToItem\n    } = this.props;\n\n    if (!this._carouselRef) {\n      return;\n    }\n\n    this._canFireCallback = false;\n    onSnapToItem && onSnapToItem(index);\n  }\n\n  startAutoplay() {\n    var {\n      autoplayInterval,\n      autoplayDelay\n    } = this.props;\n    this._autoplay = true;\n\n    if (this._autoplaying) {\n      return;\n    }\n\n    clearTimeout(this._autoplayTimeout);\n    this._autoplayTimeout = setTimeout(() => {\n      this._autoplaying = true;\n      this._autoplayInterval = setInterval(() => {\n        if (this._autoplaying) {\n          this.snapToNext();\n        }\n      }, autoplayInterval);\n    }, autoplayDelay);\n  }\n\n  pauseAutoPlay() {\n    this._autoplaying = false;\n    clearTimeout(this._autoplayTimeout);\n    clearTimeout(this._enableAutoplayTimeout);\n    clearInterval(this._autoplayInterval);\n  }\n\n  stopAutoplay() {\n    this._autoplay = false;\n    this.pauseAutoPlay();\n  }\n\n  snapToItem(index) {\n    var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var fireCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (!index || index < 0) {\n      index = 0;\n    }\n\n    var positionIndex = this._getPositionIndex(index);\n\n    if (positionIndex === this._activeItem) {\n      return;\n    }\n\n    this._snapToItem(positionIndex, animated, fireCallback);\n  }\n\n  snapToNext() {\n    var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var fireCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    var itemsLength = this._getCustomDataLength();\n\n    var newIndex = this._activeItem + 1;\n\n    if (newIndex > itemsLength - 1) {\n      if (!this._enableLoop()) {\n        return;\n      }\n\n      newIndex = 0;\n    }\n\n    this._snapToItem(newIndex, animated, fireCallback);\n  }\n\n  snapToPrev() {\n    var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var fireCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    var itemsLength = this._getCustomDataLength();\n\n    var newIndex = this._activeItem - 1;\n\n    if (newIndex < 0) {\n      if (!this._enableLoop()) {\n        return;\n      }\n\n      newIndex = itemsLength - 1;\n    }\n\n    this._snapToItem(newIndex, animated, fireCallback);\n  }\n\n  triggerRenderingHack(offset) {\n    if (Date.now() - this._lastScrollDate < 500) {\n      return;\n    }\n\n    var scrollPosition = this._currentContentOffset;\n\n    if (!scrollPosition && scrollPosition !== 0) {\n      return;\n    }\n\n    var scrollOffset = offset || (scrollPosition === 0 ? 1 : -1);\n\n    this._scrollTo(scrollPosition + scrollOffset, false);\n  }\n\n  _getSlideInterpolatedStyle(index, animatedValue) {\n    var {\n      layoutCardOffset,\n      slideInterpolatedStyle\n    } = this.props;\n\n    if (slideInterpolatedStyle) {\n      return slideInterpolatedStyle(index, animatedValue, this.props);\n    } else if (this._shouldUseTinderLayout()) {\n      return tinderAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n    } else if (this._shouldUseStackLayout()) {\n      return stackAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n    } else if (this._shouldUseShiftLayout()) {\n      return shiftAnimatedStyles(index, animatedValue, this.props);\n    } else {\n      return defaultAnimatedStyles(index, animatedValue, this.props);\n    }\n  }\n\n  _renderItem(_ref) {\n    var {\n      item,\n      index\n    } = _ref;\n    var {\n      interpolators\n    } = this.state;\n    var {\n      hasParallaxImages,\n      itemWidth,\n      itemHeight,\n      keyExtractor,\n      renderItem,\n      sliderHeight,\n      sliderWidth,\n      slideStyle,\n      vertical\n    } = this.props;\n    var animatedValue = interpolators && interpolators[index];\n\n    if (!animatedValue && animatedValue !== 0) {\n      return null;\n    }\n\n    var animate = this._shouldAnimateSlides();\n\n    var Component = animate ? Animated.View : View;\n    var animatedStyle = animate ? this._getSlideInterpolatedStyle(index, animatedValue) : {};\n    var parallaxProps = hasParallaxImages ? {\n      scrollPosition: this._scrollPos,\n      carouselRef: this._carouselRef,\n      vertical,\n      sliderWidth,\n      sliderHeight,\n      itemWidth,\n      itemHeight\n    } : undefined;\n    var mainDimension = vertical ? {\n      height: itemHeight\n    } : {\n      width: itemWidth\n    };\n    var specificProps = this._needsScrollView() ? {\n      key: keyExtractor ? keyExtractor(item, index) : this._getKeyExtractor(item, index)\n    } : {};\n    return React.createElement(Component, _extends({\n      style: [mainDimension, slideStyle, animatedStyle],\n      pointerEvents: 'box-none'\n    }, specificProps, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1237,\n        columnNumber: 13\n      }\n    }), renderItem({\n      item,\n      index\n    }, parallaxProps));\n  }\n\n  _getComponentOverridableProps() {\n    var {\n      enableMomentum,\n      itemWidth,\n      itemHeight,\n      loopClonesPerSide,\n      sliderWidth,\n      sliderHeight,\n      vertical\n    } = this.props;\n    var visibleItems = Math.ceil(vertical ? sliderHeight / itemHeight : sliderWidth / itemWidth) + 1;\n    var initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;\n    var initialNumToRender = visibleItems + initialNumPerSide * 2;\n    var maxToRenderPerBatch = 1 + initialNumToRender * 2;\n    var windowSize = maxToRenderPerBatch;\n    var specificProps = !this._needsScrollView() ? {\n      initialNumToRender: initialNumToRender,\n      maxToRenderPerBatch: maxToRenderPerBatch,\n      windowSize: windowSize\n    } : {};\n    return _objectSpread({\n      decelerationRate: enableMomentum ? 0.9 : 'fast',\n      showsHorizontalScrollIndicator: false,\n      showsVerticalScrollIndicator: false,\n      overScrollMode: 'never',\n      automaticallyAdjustContentInsets: false,\n      directionalLockEnabled: true,\n      pinchGestureEnabled: false,\n      scrollsToTop: false,\n      removeClippedSubviews: !this._needsScrollView(),\n      inverted: this._needsRTLAdaptations()\n    }, specificProps);\n  }\n\n  _getComponentStaticProps() {\n    var {\n      hideCarousel\n    } = this.state;\n    var {\n      containerCustomStyle,\n      contentContainerCustomStyle,\n      keyExtractor,\n      sliderWidth,\n      sliderHeight,\n      style,\n      vertical\n    } = this.props;\n    var containerStyle = [containerCustomStyle || style || {}, hideCarousel ? {\n      opacity: 0\n    } : {}, vertical ? {\n      height: sliderHeight,\n      flexDirection: 'column'\n    } : {\n      width: sliderWidth,\n      flexDirection: this._needsRTLAdaptations() ? 'row-reverse' : 'row'\n    }];\n    var contentContainerStyle = [vertical ? {\n      paddingTop: this._getContainerInnerMargin(),\n      paddingBottom: this._getContainerInnerMargin(true)\n    } : {\n      paddingLeft: this._getContainerInnerMargin(),\n      paddingRight: this._getContainerInnerMargin(true)\n    }, contentContainerCustomStyle || {}];\n    var specificProps = !this._needsScrollView() ? {\n      renderItem: this._renderItem,\n      numColumns: 1,\n      keyExtractor: keyExtractor || this._getKeyExtractor\n    } : {};\n    return _objectSpread({\n      ref: c => this._carouselRef = c,\n      data: this._getCustomData(),\n      style: containerStyle,\n      contentContainerStyle: contentContainerStyle,\n      horizontal: !vertical,\n      scrollEventThrottle: 1,\n      onScroll: this._onScrollHandler,\n      onScrollBeginDrag: this._onScrollBeginDrag,\n      onScrollEndDrag: this._onScrollEndDrag,\n      onMomentumScrollEnd: this._onMomentumScrollEnd,\n      onResponderRelease: this._onTouchRelease,\n      onStartShouldSetResponderCapture: this._onStartShouldSetResponderCapture,\n      onTouchStart: this._onTouchStart,\n      onTouchEnd: this._onScrollEnd,\n      onLayout: this._onLayout\n    }, specificProps);\n  }\n\n  render() {\n    var {\n      data,\n      renderItem,\n      useScrollView\n    } = this.props;\n\n    if (!data || !renderItem) {\n      return null;\n    }\n\n    var props = _objectSpread(_objectSpread(_objectSpread({}, this._getComponentOverridableProps()), this.props), this._getComponentStaticProps());\n\n    var ScrollViewComponent = typeof useScrollView === 'function' ? useScrollView : AnimatedScrollView;\n    return this._needsScrollView() ? React.createElement(ScrollViewComponent, _extends({}, props, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1360,\n        columnNumber: 13\n      }\n    }), this._getCustomData().map((item, index) => {\n      return this._renderItem({\n        item,\n        index\n      });\n    })) : React.createElement(AnimatedFlatList, _extends({}, props, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1368,\n        columnNumber: 13\n      }\n    }));\n  }\n\n}\nCarousel.propTypes = {\n  data: PropTypes.array.isRequired,\n  renderItem: PropTypes.func.isRequired,\n  itemWidth: PropTypes.number,\n  itemHeight: PropTypes.number,\n  sliderWidth: PropTypes.number,\n  sliderHeight: PropTypes.number,\n  activeAnimationType: PropTypes.string,\n  activeAnimationOptions: PropTypes.object,\n  activeSlideAlignment: PropTypes.oneOf(['center', 'end', 'start']),\n  activeSlideOffset: PropTypes.number,\n  apparitionDelay: PropTypes.number,\n  autoplay: PropTypes.bool,\n  autoplayDelay: PropTypes.number,\n  autoplayInterval: PropTypes.number,\n  callbackOffsetMargin: PropTypes.number,\n  containerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n  contentContainerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n  enableMomentum: PropTypes.bool,\n  enableSnap: PropTypes.bool,\n  firstItem: PropTypes.number,\n  hasParallaxImages: PropTypes.bool,\n  inactiveSlideOpacity: PropTypes.number,\n  inactiveSlideScale: PropTypes.number,\n  inactiveSlideShift: PropTypes.number,\n  layout: PropTypes.oneOf(['default', 'stack', 'tinder']),\n  layoutCardOffset: PropTypes.number,\n  lockScrollTimeoutDuration: PropTypes.number,\n  lockScrollWhileSnapping: PropTypes.bool,\n  loop: PropTypes.bool,\n  loopClonesPerSide: PropTypes.number,\n  scrollEnabled: PropTypes.bool,\n  scrollInterpolator: PropTypes.func,\n  slideInterpolatedStyle: PropTypes.func,\n  slideStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n  shouldOptimizeUpdates: PropTypes.bool,\n  swipeThreshold: PropTypes.number,\n  useScrollView: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n  vertical: PropTypes.bool,\n  onBeforeSnapToItem: PropTypes.func,\n  onSnapToItem: PropTypes.func\n};\nCarousel.defaultProps = {\n  activeAnimationType: 'timing',\n  activeAnimationOptions: null,\n  activeSlideAlignment: 'center',\n  activeSlideOffset: 20,\n  apparitionDelay: 0,\n  autoplay: false,\n  autoplayDelay: 1000,\n  autoplayInterval: 3000,\n  callbackOffsetMargin: 5,\n  containerCustomStyle: {},\n  contentContainerCustomStyle: {},\n  enableMomentum: false,\n  enableSnap: true,\n  firstItem: 0,\n  hasParallaxImages: false,\n  inactiveSlideOpacity: 0.7,\n  inactiveSlideScale: 0.9,\n  inactiveSlideShift: 0,\n  layout: 'default',\n  lockScrollTimeoutDuration: 1000,\n  lockScrollWhileSnapping: false,\n  loop: false,\n  loopClonesPerSide: 3,\n  scrollEnabled: true,\n  slideStyle: {},\n  shouldOptimizeUpdates: true,\n  swipeThreshold: 20,\n  useScrollView: !AnimatedFlatList,\n  vertical: false\n};","map":{"version":3,"sources":["/Users/m.asyam/Desktop/MY-PROJECTS/react-project/client-pack/node_modules/react-native-snap-carousel/src/carousel/Carousel.js"],"names":["React","Component","PropTypes","shallowCompare","defaultScrollInterpolator","stackScrollInterpolator","tinderScrollInterpolator","defaultAnimatedStyles","shiftAnimatedStyles","stackAnimatedStyles","tinderAnimatedStyles","IS_IOS","Platform","OS","AnimatedFlatList","FlatList","Animated","createAnimatedComponent","AnimatedScrollView","ScrollView","IS_RTL","I18nManager","isRTL","Carousel","constructor","props","state","hideCarousel","interpolators","initialActiveItem","_getFirstItem","firstItem","_activeItem","_previousActiveItem","_previousFirstItem","_previousItemsLength","_mounted","_positions","_currentContentOffset","_canFireBeforeCallback","_canFireCallback","_scrollOffsetRef","_onScrollTriggered","_lastScrollDate","_scrollEnabled","scrollEnabled","_initPositionsAndInterpolators","bind","_renderItem","_onSnap","_onLayout","_onScroll","_onScrollBeginDrag","enableSnap","undefined","_onScrollEnd","autoplay","_onScrollEndDrag","enableMomentum","_onMomentumScrollEnd","_onTouchStart","_onTouchEnd","_onTouchRelease","_getKeyExtractor","_setScrollHandler","_ignoreNextMomentum","ViewPropTypes","console","warn","vertical","sliderWidth","itemWidth","error","sliderHeight","itemHeight","apparitionDelay","useScrollView","customAnimationType","customAnimationOptions","onScrollViewScroll","componentDidMount","_firstItem","apparitionCallback","setState","startAutoplay","requestAnimationFrame","_snapToItem","_hackActiveSlideAnimation","_apparitionTimeout","setTimeout","shouldComponentUpdate","nextProps","nextState","shouldOptimizeUpdates","componentDidUpdate","prevProps","itemsLength","_getCustomDataLength","nextFirstItem","nextActiveItem","hasNewSliderWidth","hasNewSliderHeight","hasNewItemWidth","hasNewItemHeight","hasNewScrollEnabled","_setScrollEnabled","length","onScroll","componentWillUnmount","stopAutoplay","clearTimeout","_hackSlideAnimationTimeout","_enableAutoplayTimeout","_autoplayTimeout","_snapNoMomentumTimeout","_edgeItemTimeout","_lockScrollTimeout","realIndex","currentIndex","_getDataIndex","currentScrollPosition","scrollEventConfig","listener","useNativeDriver","_scrollPos","Value","argMapping","nativeEvent","contentOffset","y","x","Array","isArray","_argMapping","pop","argMap","push","_onScrollHandler","event","_needsScrollView","_shouldUseStackLayout","_shouldUseTinderLayout","_needsRTLAdaptations","_canLockScroll","lockScrollWhileSnapping","_enableLoop","data","loop","_shouldAnimateSlides","inactiveSlideOpacity","inactiveSlideScale","scrollInterpolator","slideInterpolatedStyle","_shouldUseShiftLayout","_shouldUseCustomAnimation","activeAnimationOptions","inactiveSlideShift","layout","_getCustomData","loopClonesPerSide","dataLength","previousItems","nextItems","dataMultiplier","Math","floor","remainder","i","unshift","slice","concat","_getCustomIndex","index","baseDataIndexes","dataIndexes","j","_getPositionIndex","_getWrappedRef","_carouselRef","scrollTo","scrollToOffset","getNode","_getScrollEnabled","wrappedRef","setNativeProps","item","_getScrollOffset","_getContainerInnerMargin","opposite","activeSlideAlignment","_getViewportOffset","_getCenter","offset","_getActiveItem","activeSlideOffset","swipeThreshold","center","centerOffset","start","end","lastIndex","sizeRef","forEach","itemData","_index","animatedValue","interpolator","inputRange","outputRange","interpolate","extrapolate","_getSlideAnimation","toValue","activeAnimationType","animationCommonOptions","isInteraction","parallel","easing","Easing","linear","_playCustomSlideAnimation","current","next","_currentIndex","_currentDataIndex","_nextIndex","_nextDataIndex","animations","stopTogether","goTo","force","direction","_scrollTo","_lockScroll","lockScrollTimeoutDuration","_releaseScroll","_repositionScroll","repositionTo","animated","specificOptions","options","callbackOffsetMargin","scrollOffset","itemReached","_itemToSnapTo","scrollConditions","Date","now","_onBeforeSnap","_onStartShouldSetResponderCapture","onStartShouldSetResponderCapture","onTouchStart","_autoplaying","pauseAutoPlay","onTouchEnd","_autoplay","onScrollBeginDrag","_scrollStartOffset","_scrollStartActive","onScrollEndDrag","onMomentumScrollEnd","autoplayDelay","_scrollEndOffset","_scrollEndActive","_snapScroll","onLayout","_onLayoutInitDone","delta","fireCallback","initial","lockScroll","onSnapToItem","onBeforeSnapToItem","autoplayInterval","_autoplayInterval","setInterval","snapToNext","clearInterval","snapToItem","positionIndex","newIndex","snapToPrev","triggerRenderingHack","scrollPosition","_getSlideInterpolatedStyle","layoutCardOffset","hasParallaxImages","keyExtractor","renderItem","slideStyle","animate","View","animatedStyle","parallaxProps","carouselRef","mainDimension","height","width","specificProps","key","_getComponentOverridableProps","visibleItems","ceil","initialNumPerSide","initialNumToRender","maxToRenderPerBatch","windowSize","decelerationRate","showsHorizontalScrollIndicator","showsVerticalScrollIndicator","overScrollMode","automaticallyAdjustContentInsets","directionalLockEnabled","pinchGestureEnabled","scrollsToTop","removeClippedSubviews","inverted","_getComponentStaticProps","containerCustomStyle","contentContainerCustomStyle","style","containerStyle","opacity","flexDirection","contentContainerStyle","paddingTop","paddingBottom","paddingLeft","paddingRight","numColumns","ref","c","horizontal","scrollEventThrottle","onResponderRelease","render","ScrollViewComponent","map","propTypes","array","isRequired","func","number","string","object","oneOf","bool","oneOfType","defaultProps"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { Animated, Easing, FlatList, I18nManager, Platform, ScrollView, View, ViewPropTypes } from 'react-native';\nimport PropTypes from 'prop-types';\nimport shallowCompare from 'react-addons-shallow-compare';\nimport {\n    defaultScrollInterpolator,\n    stackScrollInterpolator,\n    tinderScrollInterpolator,\n    defaultAnimatedStyles,\n    shiftAnimatedStyles,\n    stackAnimatedStyles,\n    tinderAnimatedStyles\n} from '../utils/animations';\n\nconst IS_IOS = Platform.OS === 'ios';\n\n// Native driver for scroll events\n// See: https://facebook.github.io/react-native/blog/2017/02/14/using-native-driver-for-animated.html\nconst AnimatedFlatList = FlatList ? Animated.createAnimatedComponent(FlatList) : null;\nconst AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);\n\n// React Native automatically handles RTL layouts; unfortunately, it's buggy with horizontal ScrollView\n// See https://github.com/facebook/react-native/issues/11960\n// NOTE: the following variable is not declared in the constructor\n// otherwise it is undefined at init, which messes with custom indexes\nconst IS_RTL = I18nManager.isRTL;\n\nexport default class Carousel extends Component {\n\n    static propTypes = {\n        data: PropTypes.array.isRequired,\n        renderItem: PropTypes.func.isRequired,\n        itemWidth: PropTypes.number, // required for horizontal carousel\n        itemHeight: PropTypes.number, // required for vertical carousel\n        sliderWidth: PropTypes.number, // required for horizontal carousel\n        sliderHeight: PropTypes.number, // required for vertical carousel\n        activeAnimationType: PropTypes.string,\n        activeAnimationOptions: PropTypes.object,\n        activeSlideAlignment: PropTypes.oneOf(['center', 'end', 'start']),\n        activeSlideOffset: PropTypes.number,\n        apparitionDelay: PropTypes.number,\n        autoplay: PropTypes.bool,\n        autoplayDelay: PropTypes.number,\n        autoplayInterval: PropTypes.number,\n        callbackOffsetMargin: PropTypes.number,\n        containerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        contentContainerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        enableMomentum: PropTypes.bool,\n        enableSnap: PropTypes.bool,\n        firstItem: PropTypes.number,\n        hasParallaxImages: PropTypes.bool,\n        inactiveSlideOpacity: PropTypes.number,\n        inactiveSlideScale: PropTypes.number,\n        inactiveSlideShift: PropTypes.number,\n        layout: PropTypes.oneOf(['default', 'stack', 'tinder']),\n        layoutCardOffset: PropTypes.number,\n        lockScrollTimeoutDuration: PropTypes.number,\n        lockScrollWhileSnapping: PropTypes.bool,\n        loop: PropTypes.bool,\n        loopClonesPerSide: PropTypes.number,\n        scrollEnabled: PropTypes.bool,\n        scrollInterpolator: PropTypes.func,\n        slideInterpolatedStyle: PropTypes.func,\n        slideStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        shouldOptimizeUpdates: PropTypes.bool,\n        swipeThreshold: PropTypes.number,\n        useScrollView: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n        vertical: PropTypes.bool,\n        onBeforeSnapToItem: PropTypes.func,\n        onSnapToItem: PropTypes.func\n    };\n\n    static defaultProps = {\n        activeAnimationType: 'timing',\n        activeAnimationOptions: null,\n        activeSlideAlignment: 'center',\n        activeSlideOffset: 20,\n        apparitionDelay: 0,\n        autoplay: false,\n        autoplayDelay: 1000,\n        autoplayInterval: 3000,\n        callbackOffsetMargin: 5,\n        containerCustomStyle: {},\n        contentContainerCustomStyle: {},\n        enableMomentum: false,\n        enableSnap: true,\n        firstItem: 0,\n        hasParallaxImages: false,\n        inactiveSlideOpacity: 0.7,\n        inactiveSlideScale: 0.9,\n        inactiveSlideShift: 0,\n        layout: 'default',\n        lockScrollTimeoutDuration: 1000,\n        lockScrollWhileSnapping: false,\n        loop: false,\n        loopClonesPerSide: 3,\n        scrollEnabled: true,\n        slideStyle: {},\n        shouldOptimizeUpdates: true,\n        swipeThreshold: 20,\n        useScrollView: !AnimatedFlatList,\n        vertical: false\n    }\n\n    constructor (props) {\n        super(props);\n\n        this.state = {\n            hideCarousel: true,\n            interpolators: []\n        };\n\n        // The following values are not stored in the state because 'setState()' is asynchronous\n        // and this results in an absolutely crappy behavior on Android while swiping (see #156)\n        const initialActiveItem = this._getFirstItem(props.firstItem);\n        this._activeItem = initialActiveItem;\n        this._previousActiveItem = initialActiveItem;\n        this._previousFirstItem = initialActiveItem;\n        this._previousItemsLength = initialActiveItem;\n\n        this._mounted = false;\n        this._positions = [];\n        this._currentContentOffset = 0; // store ScrollView's scroll position\n        this._canFireBeforeCallback = false;\n        this._canFireCallback = false;\n        this._scrollOffsetRef = null;\n        this._onScrollTriggered = true; // used when momentum is enabled to prevent an issue with edges items\n        this._lastScrollDate = 0; // used to work around a FlatList bug\n        this._scrollEnabled = props.scrollEnabled !== false;\n\n        this._initPositionsAndInterpolators = this._initPositionsAndInterpolators.bind(this);\n        this._renderItem = this._renderItem.bind(this);\n        this._onSnap = this._onSnap.bind(this);\n\n        this._onLayout = this._onLayout.bind(this);\n        this._onScroll = this._onScroll.bind(this);\n        this._onScrollBeginDrag = props.enableSnap ? this._onScrollBeginDrag.bind(this) : undefined;\n        this._onScrollEnd = props.enableSnap || props.autoplay ? this._onScrollEnd.bind(this) : undefined;\n        this._onScrollEndDrag = !props.enableMomentum ? this._onScrollEndDrag.bind(this) : undefined;\n        this._onMomentumScrollEnd = props.enableMomentum ? this._onMomentumScrollEnd.bind(this) : undefined;\n        this._onTouchStart = this._onTouchStart.bind(this);\n        this._onTouchEnd = this._onTouchEnd.bind(this);\n        this._onTouchRelease = this._onTouchRelease.bind(this);\n\n        this._getKeyExtractor = this._getKeyExtractor.bind(this);\n\n        this._setScrollHandler(props);\n\n        // This bool aims at fixing an iOS bug due to scrollTo that triggers onMomentumScrollEnd.\n        // onMomentumScrollEnd fires this._snapScroll, thus creating an infinite loop.\n        this._ignoreNextMomentum = false;\n\n        // Warnings\n        if (!ViewPropTypes) {\n            console.warn('react-native-snap-carousel: It is recommended to use at least version 0.44 of React Native with the plugin');\n        }\n        if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {\n            console.error('react-native-snap-carousel: You need to specify both `sliderWidth` and `itemWidth` for horizontal carousels');\n        }\n        if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {\n            console.error('react-native-snap-carousel: You need to specify both `sliderHeight` and `itemHeight` for vertical carousels');\n        }\n        if (props.apparitionDelay && !IS_IOS && !props.useScrollView) {\n            console.warn('react-native-snap-carousel: Using `apparitionDelay` on Android is not recommended since it can lead to rendering issues');\n        }\n        if (props.customAnimationType || props.customAnimationOptions) {\n            console.warn('react-native-snap-carousel: Props `customAnimationType` and `customAnimationOptions` have been renamed to `activeAnimationType` and `activeAnimationOptions`');\n        }\n        if (props.onScrollViewScroll) {\n            console.error('react-native-snap-carousel: Prop `onScrollViewScroll` has been removed. Use `onScroll` instead');\n        }\n    }\n\n    componentDidMount () {\n        const { apparitionDelay, autoplay, firstItem } = this.props;\n        const _firstItem = this._getFirstItem(firstItem);\n        const apparitionCallback = () => {\n            this.setState({ hideCarousel: false });\n            if (autoplay) {\n                this.startAutoplay();\n            }\n        };\n\n        this._mounted = true;\n        this._initPositionsAndInterpolators();\n\n        // Without 'requestAnimationFrame' or a `0` timeout, images will randomly not be rendered on Android...\n        requestAnimationFrame(() => {\n            if (!this._mounted) {\n                return;\n            }\n\n            this._snapToItem(_firstItem, false, false, true, false);\n            this._hackActiveSlideAnimation(_firstItem, 'start', true);\n\n            if (apparitionDelay) {\n                this._apparitionTimeout = setTimeout(() => {\n                    apparitionCallback();\n                }, apparitionDelay);\n            } else {\n                apparitionCallback();\n            }\n        });\n    }\n\n    shouldComponentUpdate (nextProps, nextState) {\n        if (this.props.shouldOptimizeUpdates === false) {\n            return true;\n        } else {\n            return shallowCompare(this, nextProps, nextState);\n        }\n    }\n\n    componentDidUpdate (prevProps) {\n        const { interpolators } = this.state;\n        const { firstItem, itemHeight, itemWidth, scrollEnabled, sliderHeight, sliderWidth } = this.props;\n        const itemsLength = this._getCustomDataLength(this.props);\n\n        if (!itemsLength) {\n            return;\n        }\n\n        const nextFirstItem = this._getFirstItem(firstItem, this.props);\n        let nextActiveItem = this._activeItem || this._activeItem === 0 ? this._activeItem : nextFirstItem;\n\n        const hasNewSliderWidth = sliderWidth && sliderWidth !== prevProps.sliderWidth;\n        const hasNewSliderHeight = sliderHeight && sliderHeight !== prevProps.sliderHeight;\n        const hasNewItemWidth = itemWidth && itemWidth !== prevProps.itemWidth;\n        const hasNewItemHeight = itemHeight && itemHeight !== prevProps.itemHeight;\n        const hasNewScrollEnabled = scrollEnabled !== prevProps.scrollEnabled;\n\n        // Prevent issues with dynamically removed items\n        if (nextActiveItem > itemsLength - 1) {\n            nextActiveItem = itemsLength - 1;\n        }\n\n        // Handle changing scrollEnabled independent of user -> carousel interaction\n        if (hasNewScrollEnabled) {\n            this._setScrollEnabled(scrollEnabled);\n        }\n\n        if (interpolators.length !== itemsLength || hasNewSliderWidth ||\n            hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n            this._activeItem = nextActiveItem;\n            this._previousItemsLength = itemsLength;\n\n            this._initPositionsAndInterpolators(this.props);\n\n            // Handle scroll issue when dynamically removing items (see #133)\n            // This also fixes first item's active state on Android\n            // Because 'initialScrollIndex' apparently doesn't trigger scroll\n            if (this._previousItemsLength > itemsLength) {\n                this._hackActiveSlideAnimation(nextActiveItem, null, true);\n            }\n\n            if (hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n                this._snapToItem(nextActiveItem, false, false, false, false);\n            }\n        } else if (nextFirstItem !== this._previousFirstItem && nextFirstItem !== this._activeItem) {\n            this._activeItem = nextFirstItem;\n            this._previousFirstItem = nextFirstItem;\n            this._snapToItem(nextFirstItem, false, true, false, false);\n        }\n\n        if (this.props.onScroll !== prevProps.onScroll) {\n          this._setScrollHandler(this.props);\n        }\n    }\n\n    componentWillUnmount () {\n        this._mounted = false;\n        this.stopAutoplay();\n        clearTimeout(this._apparitionTimeout);\n        clearTimeout(this._hackSlideAnimationTimeout);\n        clearTimeout(this._enableAutoplayTimeout);\n        clearTimeout(this._autoplayTimeout);\n        clearTimeout(this._snapNoMomentumTimeout);\n        clearTimeout(this._edgeItemTimeout);\n        clearTimeout(this._lockScrollTimeout);\n    }\n\n    get realIndex () {\n        return this._activeItem;\n    }\n\n    get currentIndex () {\n        return this._getDataIndex(this._activeItem);\n    }\n\n    get currentScrollPosition () {\n        return this._currentContentOffset;\n    }\n\n    _setScrollHandler(props) {\n      // Native driver for scroll events\n      const scrollEventConfig = {\n        listener: this._onScroll,\n        useNativeDriver: true,\n      };\n      this._scrollPos = new Animated.Value(0);\n      const argMapping = props.vertical\n        ? [{ nativeEvent: { contentOffset: { y: this._scrollPos } } }]\n        : [{ nativeEvent: { contentOffset: { x: this._scrollPos } } }];\n\n      if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {\n        // Because of a react-native issue https://github.com/facebook/react-native/issues/13294\n        argMapping.pop();\n        const [ argMap ] = props.onScroll._argMapping;\n        if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {\n          // Shares the same animated value passed in props\n          this._scrollPos =\n            argMap.nativeEvent.contentOffset.x ||\n            argMap.nativeEvent.contentOffset.y ||\n            this._scrollPos;\n        }\n        argMapping.push(...props.onScroll._argMapping);\n      }\n      this._onScrollHandler = Animated.event(\n        argMapping,\n        scrollEventConfig\n      );\n    }\n\n    _needsScrollView () {\n        const { useScrollView } = this.props;\n        return useScrollView || !AnimatedFlatList || this._shouldUseStackLayout() || this._shouldUseTinderLayout();\n    }\n\n    _needsRTLAdaptations () {\n        const { vertical } = this.props;\n        return IS_RTL && !IS_IOS && !vertical;\n    }\n\n    _canLockScroll () {\n        const { scrollEnabled, enableMomentum, lockScrollWhileSnapping } = this.props;\n        return scrollEnabled && !enableMomentum && lockScrollWhileSnapping;\n    }\n\n    _enableLoop () {\n        const { data, enableSnap, loop } = this.props;\n        return enableSnap && loop && data && data.length && data.length > 1;\n    }\n\n    _shouldAnimateSlides (props = this.props) {\n        const { inactiveSlideOpacity, inactiveSlideScale, scrollInterpolator, slideInterpolatedStyle } = props;\n        return inactiveSlideOpacity < 1 ||\n            inactiveSlideScale < 1 ||\n            !!scrollInterpolator ||\n            !!slideInterpolatedStyle ||\n            this._shouldUseShiftLayout() ||\n            this._shouldUseStackLayout() ||\n            this._shouldUseTinderLayout();\n    }\n\n    _shouldUseCustomAnimation () {\n        const { activeAnimationOptions } = this.props;\n        return !!activeAnimationOptions && !this._shouldUseStackLayout() && !this._shouldUseTinderLayout();\n    }\n\n    _shouldUseShiftLayout () {\n        const { inactiveSlideShift, layout } = this.props;\n        return layout === 'default' && inactiveSlideShift !== 0;\n    }\n\n    _shouldUseStackLayout () {\n        return this.props.layout === 'stack';\n    }\n\n    _shouldUseTinderLayout () {\n        return this.props.layout === 'tinder';\n    }\n\n    _getCustomData (props = this.props) {\n        const { data, loopClonesPerSide } = props;\n        const dataLength = data && data.length;\n\n        if (!dataLength) {\n            return [];\n        }\n\n        if (!this._enableLoop()) {\n            return data;\n        }\n\n        let previousItems = [];\n        let nextItems = [];\n\n        if (loopClonesPerSide > dataLength) {\n            const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n            const remainder = loopClonesPerSide % dataLength;\n\n            for (let i = 0; i < dataMultiplier; i++) {\n                previousItems.push(...data);\n                nextItems.push(...data);\n            }\n\n            previousItems.unshift(...data.slice(-remainder));\n            nextItems.push(...data.slice(0, remainder));\n        } else {\n            previousItems = data.slice(-loopClonesPerSide);\n            nextItems = data.slice(0, loopClonesPerSide);\n        }\n\n        return previousItems.concat(data, nextItems);\n    }\n\n    _getCustomDataLength (props = this.props) {\n        const { data, loopClonesPerSide } = props;\n        const dataLength = data && data.length;\n\n        if (!dataLength) {\n            return 0;\n        }\n\n        return this._enableLoop() ? dataLength + (2 * loopClonesPerSide) : dataLength;\n    }\n\n    _getCustomIndex (index, props = this.props) {\n        const itemsLength = this._getCustomDataLength(props);\n\n        if (!itemsLength || (!index && index !== 0)) {\n            return 0;\n        }\n\n        return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;\n    }\n\n    _getDataIndex (index) {\n        const { data, loopClonesPerSide } = this.props;\n        const dataLength = data && data.length;\n\n        if (!this._enableLoop() || !dataLength) {\n            return index;\n        }\n\n        if (index >= dataLength + loopClonesPerSide) {\n            return loopClonesPerSide > dataLength ?\n                (index - loopClonesPerSide) % dataLength :\n                index - dataLength - loopClonesPerSide;\n        } else if (index < loopClonesPerSide) {\n            // TODO: is there a simpler way of determining the interpolated index?\n            if (loopClonesPerSide > dataLength) {\n                const baseDataIndexes = [];\n                const dataIndexes = [];\n                const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n                const remainder = loopClonesPerSide % dataLength;\n\n                for (let i = 0; i < dataLength; i++) {\n                    baseDataIndexes.push(i);\n                }\n\n                for (let j = 0; j < dataMultiplier; j++) {\n                    dataIndexes.push(...baseDataIndexes);\n                }\n\n                dataIndexes.unshift(...baseDataIndexes.slice(-remainder));\n                return dataIndexes[index];\n            } else {\n                return index + dataLength - loopClonesPerSide;\n            }\n        } else {\n            return index - loopClonesPerSide;\n        }\n    }\n\n    // Used with `snapToItem()` and 'PaginationDot'\n    _getPositionIndex (index) {\n        const { loop, loopClonesPerSide } = this.props;\n        return loop ? index + loopClonesPerSide : index;\n    }\n\n    _getFirstItem (index, props = this.props) {\n        const { loopClonesPerSide } = props;\n        const itemsLength = this._getCustomDataLength(props);\n\n        if (!itemsLength || index > itemsLength - 1 || index < 0) {\n            return 0;\n        }\n\n        return this._enableLoop() ? index + loopClonesPerSide : index;\n    }\n\n    _getWrappedRef () {\n        if (this._carouselRef && (\n            (this._needsScrollView() && this._carouselRef.scrollTo) ||\n            (!this._needsScrollView() && this._carouselRef.scrollToOffset)\n        )) {\n            return this._carouselRef;\n        }\n        // https://github.com/facebook/react-native/issues/10635\n        // https://stackoverflow.com/a/48786374/8412141\n        return this._carouselRef && this._carouselRef.getNode && this._carouselRef.getNode();\n    }\n\n    _getScrollEnabled () {\n        return this._scrollEnabled;\n    }\n\n    _setScrollEnabled (scrollEnabled = true) {\n        const wrappedRef = this._getWrappedRef();\n\n        if (!wrappedRef || !wrappedRef.setNativeProps) {\n            return;\n        }\n\n        // 'setNativeProps()' is used instead of 'setState()' because the latter\n        // really takes a toll on Android behavior when momentum is disabled\n        wrappedRef.setNativeProps({ scrollEnabled });\n        this._scrollEnabled = scrollEnabled;\n    }\n\n    _getKeyExtractor (item, index) {\n        return this._needsScrollView() ? `scrollview-item-${index}` : `flatlist-item-${index}`;\n    }\n\n    _getScrollOffset (event) {\n        const { vertical } = this.props;\n        return (event && event.nativeEvent && event.nativeEvent.contentOffset &&\n            event.nativeEvent.contentOffset[vertical ? 'y' : 'x']) || 0;\n    }\n\n    _getContainerInnerMargin (opposite = false) {\n        const { sliderWidth, sliderHeight, itemWidth, itemHeight, vertical, activeSlideAlignment } = this.props;\n\n        if ((activeSlideAlignment === 'start' && !opposite) ||\n            (activeSlideAlignment === 'end' && opposite)) {\n            return 0;\n        } else if ((activeSlideAlignment === 'end' && !opposite) ||\n            (activeSlideAlignment === 'start' && opposite)) {\n            return vertical ? sliderHeight - itemHeight : sliderWidth - itemWidth;\n        } else {\n            return vertical ? (sliderHeight - itemHeight) / 2 : (sliderWidth - itemWidth) / 2;\n        }\n    }\n\n    _getViewportOffset () {\n        const { sliderWidth, sliderHeight, itemWidth, itemHeight, vertical, activeSlideAlignment } = this.props;\n\n        if (activeSlideAlignment === 'start') {\n            return vertical ? itemHeight / 2 : itemWidth / 2;\n        } else if (activeSlideAlignment === 'end') {\n            return vertical ?\n                sliderHeight - (itemHeight / 2) :\n                sliderWidth - (itemWidth / 2);\n        } else {\n            return vertical ? sliderHeight / 2 : sliderWidth / 2;\n        }\n    }\n\n    _getCenter (offset) {\n        return offset + this._getViewportOffset() - this._getContainerInnerMargin();\n    }\n\n    _getActiveItem (offset) {\n        const { activeSlideOffset, swipeThreshold } = this.props;\n        const center = this._getCenter(offset);\n        const centerOffset = activeSlideOffset || swipeThreshold;\n\n        for (let i = 0; i < this._positions.length; i++) {\n            const { start, end } = this._positions[i];\n            if (center + centerOffset >= start && center - centerOffset <= end) {\n                return i;\n            }\n        }\n\n        const lastIndex = this._positions.length - 1;\n        if (this._positions[lastIndex] && center - centerOffset > this._positions[lastIndex].end) {\n            return lastIndex;\n        }\n\n        return 0;\n    }\n\n    _initPositionsAndInterpolators (props = this.props) {\n        const { data, itemWidth, itemHeight, scrollInterpolator, vertical } = props;\n        const sizeRef = vertical ? itemHeight : itemWidth;\n\n        if (!data || !data.length) {\n            return;\n        }\n\n        let interpolators = [];\n        this._positions = [];\n\n        this._getCustomData(props).forEach((itemData, index) => {\n            const _index = this._getCustomIndex(index, props);\n            let animatedValue;\n\n            this._positions[index] = {\n                start: index * sizeRef,\n                end: index * sizeRef + sizeRef\n            };\n\n            if (!this._shouldAnimateSlides(props)) {\n                animatedValue = new Animated.Value(1);\n            } else if (this._shouldUseCustomAnimation()) {\n                animatedValue = new Animated.Value(_index === this._activeItem ? 1 : 0);\n            } else {\n                let interpolator;\n\n                if (scrollInterpolator) {\n                    interpolator = scrollInterpolator(_index, props);\n                } else if (this._shouldUseStackLayout()) {\n                    interpolator = stackScrollInterpolator(_index, props);\n                } else if (this._shouldUseTinderLayout()) {\n                    interpolator = tinderScrollInterpolator(_index, props);\n                }\n\n                if (!interpolator || !interpolator.inputRange || !interpolator.outputRange) {\n                    interpolator = defaultScrollInterpolator(_index, props);\n                }\n\n                animatedValue = this._scrollPos.interpolate({\n                    ...interpolator,\n                    extrapolate: 'clamp'\n                });\n            }\n\n            interpolators.push(animatedValue);\n        });\n\n        this.setState({ interpolators });\n    }\n\n    _getSlideAnimation (index, toValue) {\n        const { interpolators } = this.state;\n        const { activeAnimationType, activeAnimationOptions } = this.props;\n\n        const animatedValue = interpolators && interpolators[index];\n\n        if (!animatedValue && animatedValue !== 0) {\n            return null;\n        }\n\n        const animationCommonOptions = {\n            isInteraction: false,\n            useNativeDriver: true,\n            ...activeAnimationOptions,\n            toValue: toValue\n        };\n\n        return Animated.parallel([\n            Animated['timing'](\n                animatedValue,\n                { ...animationCommonOptions, easing: Easing.linear }\n            ),\n            Animated[activeAnimationType](\n                animatedValue,\n                { ...animationCommonOptions }\n            )\n        ]);\n    }\n\n    _playCustomSlideAnimation (current, next) {\n        const { interpolators } = this.state;\n        const itemsLength = this._getCustomDataLength();\n        const _currentIndex = this._getCustomIndex(current);\n        const _currentDataIndex = this._getDataIndex(_currentIndex);\n        const _nextIndex = this._getCustomIndex(next);\n        const _nextDataIndex = this._getDataIndex(_nextIndex);\n        let animations = [];\n\n        // Keep animations in sync when looping\n        if (this._enableLoop()) {\n            for (let i = 0; i < itemsLength; i++) {\n                if (this._getDataIndex(i) === _currentDataIndex && interpolators[i]) {\n                    animations.push(this._getSlideAnimation(i, 0));\n                } else if (this._getDataIndex(i) === _nextDataIndex && interpolators[i]) {\n                    animations.push(this._getSlideAnimation(i, 1));\n                }\n            }\n        } else {\n            if (interpolators[current]) {\n                animations.push(this._getSlideAnimation(current, 0));\n            }\n            if (interpolators[next]) {\n                animations.push(this._getSlideAnimation(next, 1));\n            }\n        }\n\n        Animated.parallel(animations, { stopTogether: false }).start();\n    }\n\n    _hackActiveSlideAnimation (index, goTo, force = false) {\n        const { data } = this.props;\n\n        if (!this._mounted || !this._carouselRef || !this._positions[index] || (!force && this._enableLoop())) {\n            return;\n        }\n\n        const offset = this._positions[index] && this._positions[index].start;\n\n        if (!offset && offset !== 0) {\n            return;\n        }\n\n        const itemsLength = data && data.length;\n        const direction = goTo || itemsLength === 1 ? 'start' : 'end';\n\n        this._scrollTo(offset + (direction === 'start' ? -1 : 1), false);\n\n        clearTimeout(this._hackSlideAnimationTimeout);\n        this._hackSlideAnimationTimeout = setTimeout(() => {\n            this._scrollTo(offset, false);\n        }, 50); // works randomly when set to '0'\n    }\n\n    _lockScroll () {\n        const { lockScrollTimeoutDuration } = this.props;\n        clearTimeout(this._lockScrollTimeout);\n        this._lockScrollTimeout = setTimeout(() => {\n            this._releaseScroll();\n        }, lockScrollTimeoutDuration);\n        this._setScrollEnabled(false);\n    }\n\n    _releaseScroll () {\n        clearTimeout(this._lockScrollTimeout);\n        this._setScrollEnabled(true);\n    }\n\n    _repositionScroll (index) {\n        const { data, loopClonesPerSide } = this.props;\n        const dataLength = data && data.length;\n\n        if (!this._enableLoop() || !dataLength ||\n            (index >= loopClonesPerSide && index < dataLength + loopClonesPerSide)) {\n            return;\n        }\n\n        let repositionTo = index;\n\n        if (index >= dataLength + loopClonesPerSide) {\n            repositionTo = index - dataLength;\n        } else if (index < loopClonesPerSide) {\n            repositionTo = index + dataLength;\n        }\n\n        this._snapToItem(repositionTo, false, false, false, false);\n    }\n\n    _scrollTo (offset, animated = true) {\n        const { vertical } = this.props;\n        const wrappedRef = this._getWrappedRef();\n\n        if (!this._mounted || !wrappedRef) {\n            return;\n        }\n\n        const specificOptions = this._needsScrollView() ? {\n            x: vertical ? 0 : offset,\n            y: vertical ? offset : 0\n        } : {\n            offset\n        };\n        const options = {\n            ...specificOptions,\n            animated\n        };\n\n        if (this._needsScrollView()) {\n            wrappedRef.scrollTo(options);\n        } else {\n            wrappedRef.scrollToOffset(options);\n        }\n    }\n\n    _onScroll (event) {\n        const { callbackOffsetMargin, enableMomentum, onScroll } = this.props;\n\n        const scrollOffset = event ? this._getScrollOffset(event) : this._currentContentOffset;\n        const nextActiveItem = this._getActiveItem(scrollOffset);\n        const itemReached = nextActiveItem === this._itemToSnapTo;\n        const scrollConditions =\n            scrollOffset >= this._scrollOffsetRef - callbackOffsetMargin &&\n            scrollOffset <= this._scrollOffsetRef + callbackOffsetMargin;\n\n        this._currentContentOffset = scrollOffset;\n        this._onScrollTriggered = true;\n        this._lastScrollDate = Date.now();\n\n        if (this._activeItem !== nextActiveItem && this._shouldUseCustomAnimation()) {\n            this._playCustomSlideAnimation(this._activeItem, nextActiveItem);\n        }\n\n        if (enableMomentum) {\n            clearTimeout(this._snapNoMomentumTimeout);\n\n            if (this._activeItem !== nextActiveItem) {\n                this._activeItem = nextActiveItem;\n            }\n\n            if (itemReached) {\n                if (this._canFireBeforeCallback) {\n                    this._onBeforeSnap(this._getDataIndex(nextActiveItem));\n                }\n\n                if (scrollConditions && this._canFireCallback) {\n                    this._onSnap(this._getDataIndex(nextActiveItem));\n                }\n            }\n        } else if (this._activeItem !== nextActiveItem && itemReached) {\n            if (this._canFireBeforeCallback) {\n                this._onBeforeSnap(this._getDataIndex(nextActiveItem));\n            }\n\n            if (scrollConditions) {\n                this._activeItem = nextActiveItem;\n\n                if (this._canLockScroll()) {\n                    this._releaseScroll();\n                }\n\n                if (this._canFireCallback) {\n                    this._onSnap(this._getDataIndex(nextActiveItem));\n                }\n            }\n        }\n\n        if (nextActiveItem === this._itemToSnapTo &&\n            scrollOffset === this._scrollOffsetRef) {\n            this._repositionScroll(nextActiveItem);\n        }\n\n        if (typeof onScroll === \"function\" && event) {\n            onScroll(event);\n        }\n    }\n\n    _onStartShouldSetResponderCapture (event) {\n        const { onStartShouldSetResponderCapture } = this.props;\n\n        if (onStartShouldSetResponderCapture) {\n            onStartShouldSetResponderCapture(event);\n        }\n\n        return this._getScrollEnabled();\n    }\n\n    _onTouchStart () {\n        const { onTouchStart } = this.props\n\n        // `onTouchStart` is fired even when `scrollEnabled` is set to `false`\n        if (this._getScrollEnabled() !== false && this._autoplaying) {\n            this.pauseAutoPlay();\n        }\n\n        if (onTouchStart) {\n            onTouchStart()\n        }\n    }\n\n    _onTouchEnd () {\n        const { onTouchEnd } = this.props\n\n        if (this._getScrollEnabled() !== false && this._autoplay && !this._autoplaying) {\n            // This event is buggy on Android, so a fallback is provided in _onScrollEnd()\n            this.startAutoplay();\n        }\n\n        if (onTouchEnd) {\n            onTouchEnd()\n        }\n    }\n\n    // Used when `enableSnap` is ENABLED\n    _onScrollBeginDrag (event) {\n        const { onScrollBeginDrag } = this.props;\n\n        if (!this._getScrollEnabled()) {\n            return;\n        }\n\n        this._scrollStartOffset = this._getScrollOffset(event);\n        this._scrollStartActive = this._getActiveItem(this._scrollStartOffset);\n        this._ignoreNextMomentum = false;\n        // this._canFireCallback = false;\n\n        if (onScrollBeginDrag) {\n            onScrollBeginDrag(event);\n        }\n    }\n\n    // Used when `enableMomentum` is DISABLED\n    _onScrollEndDrag (event) {\n        const { onScrollEndDrag } = this.props;\n\n        if (this._carouselRef) {\n            this._onScrollEnd && this._onScrollEnd();\n        }\n\n        if (onScrollEndDrag) {\n            onScrollEndDrag(event);\n        }\n    }\n\n    // Used when `enableMomentum` is ENABLED\n    _onMomentumScrollEnd (event) {\n        const { onMomentumScrollEnd } = this.props;\n\n        if (this._carouselRef) {\n            this._onScrollEnd && this._onScrollEnd();\n        }\n\n        if (onMomentumScrollEnd) {\n            onMomentumScrollEnd(event);\n        }\n    }\n\n    _onScrollEnd (event) {\n        const { autoplayDelay, enableSnap } = this.props;\n\n        if (this._ignoreNextMomentum) {\n            // iOS fix\n            this._ignoreNextMomentum = false;\n            return;\n        }\n\n        if (this._currentContentOffset === this._scrollEndOffset) {\n            return;\n        }\n\n        this._scrollEndOffset = this._currentContentOffset;\n        this._scrollEndActive = this._getActiveItem(this._scrollEndOffset);\n\n        if (enableSnap) {\n            this._snapScroll(this._scrollEndOffset - this._scrollStartOffset);\n        }\n\n        // The touchEnd event is buggy on Android, so this will serve as a fallback whenever needed\n        // https://github.com/facebook/react-native/issues/9439\n        if (this._autoplay && !this._autoplaying) {\n            clearTimeout(this._enableAutoplayTimeout);\n            this._enableAutoplayTimeout = setTimeout(() => {\n                this.startAutoplay();\n            }, autoplayDelay + 50);\n        }\n    }\n\n    // Due to a bug, this event is only fired on iOS\n    // https://github.com/facebook/react-native/issues/6791\n    // it's fine since we're only fixing an iOS bug in it, so ...\n    _onTouchRelease (event) {\n        const { enableMomentum } = this.props;\n\n        if (enableMomentum && IS_IOS) {\n            clearTimeout(this._snapNoMomentumTimeout);\n            this._snapNoMomentumTimeout = setTimeout(() => {\n                this._snapToItem(this._activeItem);\n            }, 100);\n        }\n    }\n\n    _onLayout (event) {\n        const { onLayout } = this.props;\n\n        // Prevent unneeded actions during the first 'onLayout' (triggered on init)\n        if (this._onLayoutInitDone) {\n            this._initPositionsAndInterpolators();\n            this._snapToItem(this._activeItem, false, false, false, false);\n        } else {\n            this._onLayoutInitDone = true;\n        }\n\n        if (onLayout) {\n            onLayout(event);\n        }\n    }\n\n    _snapScroll (delta) {\n        const { swipeThreshold } = this.props;\n\n        // When using momentum and releasing the touch with\n        // no velocity, scrollEndActive will be undefined (iOS)\n        if (!this._scrollEndActive && this._scrollEndActive !== 0 && IS_IOS) {\n            this._scrollEndActive = this._scrollStartActive;\n        }\n\n        if (this._scrollStartActive !== this._scrollEndActive) {\n            // Snap to the new active item\n            this._snapToItem(this._scrollEndActive);\n        } else {\n            // Snap depending on delta\n            if (delta > 0) {\n                if (delta > swipeThreshold) {\n                    this._snapToItem(this._scrollStartActive + 1);\n                } else {\n                    this._snapToItem(this._scrollEndActive);\n                }\n            } else if (delta < 0) {\n                if (delta < -swipeThreshold) {\n                    this._snapToItem(this._scrollStartActive - 1);\n                } else {\n                    this._snapToItem(this._scrollEndActive);\n                }\n            } else {\n                // Snap to current\n                this._snapToItem(this._scrollEndActive);\n            }\n        }\n    }\n\n    _snapToItem (index, animated = true, fireCallback = true, initial = false, lockScroll = true) {\n        const { enableMomentum, onSnapToItem, onBeforeSnapToItem } = this.props;\n        const itemsLength = this._getCustomDataLength();\n        const wrappedRef = this._getWrappedRef();\n\n        if (!itemsLength || !wrappedRef) {\n            return;\n        }\n\n        if (!index || index < 0) {\n            index = 0;\n        } else if (itemsLength > 0 && index >= itemsLength) {\n            index = itemsLength - 1;\n        }\n\n        if (index !== this._previousActiveItem) {\n            this._previousActiveItem = index;\n\n            // Placed here to allow overscrolling for edges items\n            if (lockScroll && this._canLockScroll()) {\n                this._lockScroll();\n            }\n\n            if (fireCallback) {\n                if (onBeforeSnapToItem) {\n                    this._canFireBeforeCallback = true;\n                }\n\n                if (onSnapToItem) {\n                    this._canFireCallback = true;\n                }\n            }\n        }\n\n        this._itemToSnapTo = index;\n        this._scrollOffsetRef = this._positions[index] && this._positions[index].start;\n        this._onScrollTriggered = false;\n\n        if (!this._scrollOffsetRef && this._scrollOffsetRef !== 0) {\n            return;\n        }\n\n        this._scrollTo(this._scrollOffsetRef, animated);\n\n        this._scrollEndOffset = this._currentContentOffset;\n\n        if (enableMomentum) {\n            // iOS fix, check the note in the constructor\n            if (!initial) {\n                this._ignoreNextMomentum = true;\n            }\n\n            // When momentum is enabled and the user is overscrolling or swiping very quickly,\n            // 'onScroll' is not going to be triggered for edge items. Then callback won't be\n            // fired and loop won't work since the scrollview is not going to be repositioned.\n            // As a workaround, '_onScroll()' will be called manually for these items if a given\n            // condition hasn't been met after a small delay.\n            // WARNING: this is ok only when relying on 'momentumScrollEnd', not with 'scrollEndDrag'\n            if (index === 0 || index === itemsLength - 1) {\n                clearTimeout(this._edgeItemTimeout);\n                this._edgeItemTimeout = setTimeout(() => {\n                    if (!initial && index === this._activeItem && !this._onScrollTriggered) {\n                        this._onScroll();\n                    }\n                }, 250);\n            }\n        }\n    }\n\n    _onBeforeSnap (index) {\n        const { onBeforeSnapToItem } = this.props;\n\n        if (!this._carouselRef) {\n            return;\n        }\n\n        this._canFireBeforeCallback = false;\n        onBeforeSnapToItem && onBeforeSnapToItem(index);\n    }\n\n    _onSnap (index) {\n        const { onSnapToItem } = this.props;\n\n        if (!this._carouselRef) {\n            return;\n        }\n\n        this._canFireCallback = false;\n        onSnapToItem && onSnapToItem(index);\n    }\n\n    startAutoplay () {\n        const { autoplayInterval, autoplayDelay } = this.props;\n        this._autoplay = true;\n\n        if (this._autoplaying) {\n            return;\n        }\n\n        clearTimeout(this._autoplayTimeout);\n        this._autoplayTimeout = setTimeout(() => {\n            this._autoplaying = true;\n            this._autoplayInterval = setInterval(() => {\n                if (this._autoplaying) {\n                    this.snapToNext();\n                }\n            }, autoplayInterval);\n        }, autoplayDelay);\n    }\n\n    pauseAutoPlay () {\n        this._autoplaying = false;\n        clearTimeout(this._autoplayTimeout);\n        clearTimeout(this._enableAutoplayTimeout);\n        clearInterval(this._autoplayInterval);\n    }\n\n    stopAutoplay () {\n        this._autoplay = false;\n        this.pauseAutoPlay();\n    }\n\n    snapToItem (index, animated = true, fireCallback = true) {\n        if (!index || index < 0) {\n            index = 0;\n        }\n\n        const positionIndex = this._getPositionIndex(index);\n\n        if (positionIndex === this._activeItem) {\n            return;\n        }\n\n        this._snapToItem(positionIndex, animated, fireCallback);\n    }\n\n    snapToNext (animated = true, fireCallback = true) {\n        const itemsLength = this._getCustomDataLength();\n\n        let newIndex = this._activeItem + 1;\n        if (newIndex > itemsLength - 1) {\n            if (!this._enableLoop()) {\n                return;\n            }\n            newIndex = 0;\n        }\n        this._snapToItem(newIndex, animated, fireCallback);\n    }\n\n    snapToPrev (animated = true, fireCallback = true) {\n        const itemsLength = this._getCustomDataLength();\n\n        let newIndex = this._activeItem - 1;\n        if (newIndex < 0) {\n            if (!this._enableLoop()) {\n                return;\n            }\n            newIndex = itemsLength - 1;\n        }\n        this._snapToItem(newIndex, animated, fireCallback);\n    }\n\n    // https://github.com/facebook/react-native/issues/1831#issuecomment-231069668\n    triggerRenderingHack (offset) {\n        // Avoid messing with user scroll\n        if (Date.now() - this._lastScrollDate < 500) {\n            return;\n        }\n\n        const scrollPosition = this._currentContentOffset;\n        if (!scrollPosition && scrollPosition !== 0) {\n            return;\n        }\n\n        const scrollOffset = offset || (scrollPosition === 0 ? 1 : -1);\n        this._scrollTo(scrollPosition + scrollOffset, false);\n    }\n\n    _getSlideInterpolatedStyle (index, animatedValue) {\n        const { layoutCardOffset, slideInterpolatedStyle } = this.props;\n\n        if (slideInterpolatedStyle) {\n            return slideInterpolatedStyle(index, animatedValue, this.props);\n        } else if (this._shouldUseTinderLayout()) {\n            return tinderAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n        } else if (this._shouldUseStackLayout()) {\n            return stackAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n        } else if (this._shouldUseShiftLayout()) {\n            return shiftAnimatedStyles(index, animatedValue, this.props);\n        } else {\n            return defaultAnimatedStyles(index, animatedValue, this.props);\n        }\n    }\n\n    _renderItem ({ item, index }) {\n        const { interpolators } = this.state;\n        const {\n            hasParallaxImages,\n            itemWidth,\n            itemHeight,\n            keyExtractor,\n            renderItem,\n            sliderHeight,\n            sliderWidth,\n            slideStyle,\n            vertical\n        } = this.props;\n\n        const animatedValue = interpolators && interpolators[index];\n\n        if (!animatedValue && animatedValue !== 0) {\n            return null;\n        }\n\n        const animate = this._shouldAnimateSlides();\n        const Component = animate ? Animated.View : View;\n        const animatedStyle = animate ? this._getSlideInterpolatedStyle(index, animatedValue) : {};\n\n        const parallaxProps = hasParallaxImages ? {\n            scrollPosition: this._scrollPos,\n            carouselRef: this._carouselRef,\n            vertical,\n            sliderWidth,\n            sliderHeight,\n            itemWidth,\n            itemHeight\n        } : undefined;\n\n        const mainDimension = vertical ? { height: itemHeight } : { width: itemWidth };\n        const specificProps = this._needsScrollView() ? {\n            key: keyExtractor ? keyExtractor(item, index) : this._getKeyExtractor(item, index)\n        } : {};\n\n        return (\n            <Component style={[mainDimension, slideStyle, animatedStyle]} pointerEvents={'box-none'} {...specificProps}>\n                { renderItem({ item, index }, parallaxProps) }\n            </Component>\n        );\n    }\n\n    _getComponentOverridableProps () {\n        const {\n            enableMomentum,\n            itemWidth,\n            itemHeight,\n            loopClonesPerSide,\n            sliderWidth,\n            sliderHeight,\n            vertical\n        } = this.props;\n\n        const visibleItems = Math.ceil(vertical ?\n            sliderHeight / itemHeight :\n            sliderWidth / itemWidth) + 1;\n        const initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;\n        const initialNumToRender = visibleItems + (initialNumPerSide * 2);\n        const maxToRenderPerBatch = 1 + (initialNumToRender * 2);\n        const windowSize = maxToRenderPerBatch;\n\n        const specificProps = !this._needsScrollView() ? {\n            initialNumToRender: initialNumToRender,\n            maxToRenderPerBatch: maxToRenderPerBatch,\n            windowSize: windowSize\n            // updateCellsBatchingPeriod\n        } : {};\n\n        return {\n            decelerationRate: enableMomentum ? 0.9 : 'fast',\n            showsHorizontalScrollIndicator: false,\n            showsVerticalScrollIndicator: false,\n            overScrollMode: 'never',\n            automaticallyAdjustContentInsets: false,\n            directionalLockEnabled: true,\n            pinchGestureEnabled: false,\n            scrollsToTop: false,\n            removeClippedSubviews: !this._needsScrollView(),\n            inverted: this._needsRTLAdaptations(),\n            // renderToHardwareTextureAndroid: true,\n            ...specificProps\n        };\n    }\n\n    _getComponentStaticProps () {\n        const { hideCarousel } = this.state;\n        const {\n            containerCustomStyle,\n            contentContainerCustomStyle,\n            keyExtractor,\n            sliderWidth,\n            sliderHeight,\n            style,\n            vertical\n        } = this.props;\n\n        const containerStyle = [\n            containerCustomStyle || style || {},\n            hideCarousel ? { opacity: 0 } : {},\n            vertical ?\n                { height: sliderHeight, flexDirection: 'column' } :\n                // LTR hack; see https://github.com/facebook/react-native/issues/11960\n                // and https://github.com/facebook/react-native/issues/13100#issuecomment-328986423\n                { width: sliderWidth, flexDirection: this._needsRTLAdaptations() ? 'row-reverse' : 'row' }\n        ];\n        const contentContainerStyle = [\n            vertical ? {\n                paddingTop: this._getContainerInnerMargin(),\n                paddingBottom: this._getContainerInnerMargin(true)\n            } : {\n                paddingLeft: this._getContainerInnerMargin(),\n                paddingRight: this._getContainerInnerMargin(true)\n            },\n            contentContainerCustomStyle || {}\n        ];\n\n        const specificProps = !this._needsScrollView() ? {\n            // extraData: this.state,\n            renderItem: this._renderItem,\n            numColumns: 1,\n            keyExtractor: keyExtractor || this._getKeyExtractor\n        } : {};\n\n        return {\n            ref: c => this._carouselRef = c,\n            data: this._getCustomData(),\n            style: containerStyle,\n            contentContainerStyle: contentContainerStyle,\n            horizontal: !vertical,\n            scrollEventThrottle: 1,\n            onScroll: this._onScrollHandler,\n            onScrollBeginDrag: this._onScrollBeginDrag,\n            onScrollEndDrag: this._onScrollEndDrag,\n            onMomentumScrollEnd: this._onMomentumScrollEnd,\n            onResponderRelease: this._onTouchRelease,\n            onStartShouldSetResponderCapture: this._onStartShouldSetResponderCapture,\n            onTouchStart: this._onTouchStart,\n            onTouchEnd: this._onScrollEnd,\n            onLayout: this._onLayout,\n            ...specificProps\n        };\n    }\n\n    render () {\n        const { data, renderItem, useScrollView } = this.props;\n\n        if (!data || !renderItem) {\n            return null;\n        }\n\n        const props = {\n            ...this._getComponentOverridableProps(),\n            ...this.props,\n            ...this._getComponentStaticProps()\n        };\n\n        const ScrollViewComponent = typeof useScrollView === 'function' ? useScrollView : AnimatedScrollView\n\n        return this._needsScrollView() ? (\n            <ScrollViewComponent {...props}>\n                {\n                    this._getCustomData().map((item, index) => {\n                        return this._renderItem({ item, index });\n                    })\n                }\n            </ScrollViewComponent>\n        ) : (\n            <AnimatedFlatList {...props} />\n        );\n    }\n}\n"]},"metadata":{},"sourceType":"module"}