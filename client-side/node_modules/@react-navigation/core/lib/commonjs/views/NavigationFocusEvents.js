"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * @typedef {object} State
 * @prop {number} index
 * @prop {({ key: string } & (State | {}))[]} routes
 * @prop {boolean} [isTransitioning]
 *
 * @typedef {object} ParentPayload
 * @prop {string} type
 * @prop {object} action
 * @prop {State} state
 * @prop {State | {key: string, routes?: undefined, index?: undefined, isTransitioning?: undefined} | undefined | null} lastState
 * @prop {string} [context]
 *
 * @typedef {object} Payload
 * @prop {string} type
 * @prop {object} action
 * @prop {State | {key: string}} state
 * @prop {State | {key: string} | undefined | null} lastState
 * @prop {string} [context]
 *
 * @typedef {object} Props
 * @prop {object} navigation
 * @prop {Function} navigation.addListener
 * @prop {Function} navigation.removeListener
 * @prop {() => boolean} navigation.isFocused
 * @prop {() => object | undefined} navigation.dangerouslyGetParent
 * @prop {State} navigation.state
 * @prop {(target: string, type: string, data: any) => void} onEvent
 *
 * @extends {React.Component<Props>}
 */
class NavigationEventManager extends React.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "_actionSubscription", void 0);

    _defineProperty(this, "_willFocusSubscription", void 0);

    _defineProperty(this, "_willBlurSubscription", void 0);

    _defineProperty(this, "_lastWillBlurKey", void 0);

    _defineProperty(this, "_lastWillFocusKey", void 0);

    _defineProperty(this, "_handleAction", ({
      state,
      lastState,
      action,
      type,
      context
    }) => {
      var _lastState$routes;

      const {
        navigation,
        onEvent
      } = this.props; // We should only emit events when the navigator is focused
      // When navigator is not focused, screens inside shouldn't receive focused status either

      if (!navigation.isFocused()) {
        return;
      }

      const previous = lastState ? (_lastState$routes = lastState.routes) === null || _lastState$routes === void 0 ? void 0 : _lastState$routes[lastState.index] : undefined;
      const current = state.routes[state.index];
      const payload = {
        context: "".concat(current.key, ":").concat(action.type, "_").concat(context || 'Root'),
        state: current,
        lastState: previous,
        action,
        type
      };

      if ((previous === null || previous === void 0 ? void 0 : previous.key) !== current.key) {
        this._emitFocus(current.key, payload);

        if (previous === null || previous === void 0 ? void 0 : previous.key) {
          this._emitBlur(previous.key, payload);
        }
      }

      if ((lastState === null || lastState === void 0 ? void 0 : lastState.isTransitioning) !== state.isTransitioning && state.isTransitioning === false) {
        if (this._lastWillBlurKey) {
          onEvent(this._lastWillBlurKey, 'didBlur', payload);
        }

        if (this._lastWillFocusKey) {
          onEvent(this._lastWillFocusKey, 'didFocus', payload);
        }
      }

      onEvent(current.key, 'action', payload);
    });

    _defineProperty(this, "_handleWillFocus", ({
      lastState,
      action,
      context,
      type
    }) => {
      var _lastState$routes2;

      const {
        navigation
      } = this.props;
      const route = navigation.state.routes[navigation.state.index];

      this._emitFocus(route.key, {
        context: "".concat(route.key, ":").concat(action.type, "_").concat(context || 'Root'),
        state: route,
        lastState: lastState === null || lastState === void 0 ? void 0 : (_lastState$routes2 = lastState.routes) === null || _lastState$routes2 === void 0 ? void 0 : _lastState$routes2.find(r => r.key === route.key),
        action,
        type
      });
    });

    _defineProperty(this, "_handleWillBlur", ({
      lastState,
      action,
      context,
      type
    }) => {
      var _lastState$routes3;

      const {
        navigation
      } = this.props;
      const route = navigation.state.routes[navigation.state.index];

      this._emitBlur(route.key, {
        context: "".concat(route.key, ":").concat(action.type, "_").concat(context || 'Root'),
        state: route,
        lastState: lastState === null || lastState === void 0 ? void 0 : (_lastState$routes3 = lastState.routes) === null || _lastState$routes3 === void 0 ? void 0 : _lastState$routes3.find(r => r.key === route.key),
        action,
        type
      });
    });

    _defineProperty(this, "_emitFocus", (target, payload) => {
      if (this._lastWillBlurKey === target) {
        this._lastWillBlurKey = undefined;
      }

      if (this._lastWillFocusKey === target) {
        return;
      }

      this._lastWillFocusKey = target;
      const {
        navigation,
        onEvent
      } = this.props;
      onEvent(target, 'willFocus', payload);

      if (typeof navigation.state.isTransitioning !== 'boolean') {
        onEvent(target, 'didFocus', payload);
      }
    });

    _defineProperty(this, "_emitBlur", (target, payload) => {
      if (this._lastWillFocusKey === target) {
        this._lastWillFocusKey = undefined;
      }

      if (this._lastWillBlurKey === target) {
        return;
      }

      this._lastWillBlurKey = target;
      const {
        navigation,
        onEvent
      } = this.props;
      onEvent(target, 'willBlur', payload);

      if (typeof navigation.state.isTransitioning !== 'boolean') {
        onEvent(target, 'didBlur', payload);
      }
    });
  }

  componentDidMount() {
    const {
      navigation
    } = this.props;
    this._actionSubscription = navigation.addListener('action', this._handleAction);
    this._willFocusSubscription = navigation.addListener('willFocus', this._handleWillFocus);
    this._willBlurSubscription = navigation.addListener('willBlur', this._handleWillBlur);
  }

  componentWillUnmount() {
    var _this$_actionSubscrip, _this$_willFocusSubsc, _this$_willBlurSubscr;

    (_this$_actionSubscrip = this._actionSubscription) === null || _this$_actionSubscrip === void 0 ? void 0 : _this$_actionSubscrip.remove();
    (_this$_willFocusSubsc = this._willFocusSubscription) === null || _this$_willFocusSubsc === void 0 ? void 0 : _this$_willFocusSubsc.remove();
    (_this$_willBlurSubscr = this._willBlurSubscription) === null || _this$_willBlurSubscr === void 0 ? void 0 : _this$_willBlurSubscr.remove();
  }
  /**
   * @type {{ remove(): void } | undefined}
   */


  render() {
    return null;
  }

}

exports.default = NavigationEventManager;
//# sourceMappingURL=NavigationFocusEvents.js.map